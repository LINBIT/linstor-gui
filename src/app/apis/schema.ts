/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v1/actions/snapshot/multi": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * creates one snapshot for multiple resources each
         * @description Suspends IO for all given resources before taking the snapshots on
         *     all participating nodes before resuming IO again.
         *
         */
        post: operations["createMultiSnapshot"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/storage-pool-definitions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lists storage pool definitions
         * @description Returns an array of all storage pool definitions
         */
        get: operations["storagePoolDfnList"];
        put?: never;
        /**
         * add a storage pool definition to Linstor
         * @description Adds a storage pool definition to Linstor
         *
         */
        post: operations["storagePoolDfnAdd"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/storage-pool-definitions/{storagepool}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        /**
         * Lists a specific storage pool definition
         * @description Returns a specific storage pool definition
         */
        get: operations["storagePoolDfnGet"];
        /**
         * modify a storage pool definition
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `MaxOversubscriptionRatio` - range[`1-1000`]
         *
         */
        put: operations["storPoolDfnModify"];
        post?: never;
        /**
         * delete a storage pool definition
         * @description Delete a storage pool definition from Linstor
         */
        delete: operations["storagePoolDefinitionDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/storage-pool-definitions/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all storage-pool-definition properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given storage pool definition.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lists nodes registered to the controller
         * @description Returns an array of all nodes registered to Linstor.
         *
         */
        get: operations["nodeList"];
        put?: never;
        /**
         * add a node to Linstor
         * @description Adds a node to Linstor
         *
         *     If only one net-interface is specified and it is does not specify
         *     a `satellite_port` it will apply the default port and `satellite_encryption_type`
         *     for this net-interface.
         *
         */
        post: operations["nodeAdd"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/stats/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return stats of all nodes.
         * @description Returns a node stats object.
         *
         */
        get: operations["nodeStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a node
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Preferred network interface to use
         *
         *     - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use.
         *
         *     - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use for external metadata.
         *
         *     - `sys/fs/blkio_throttle_read` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
         *
         *     - `sys/fs/blkio_throttle_write` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
         *
         *     - `sys/fs/blkio_throttle_read_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
         *
         *     - `sys/fs/blkio_throttle_write_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
         *
         *     - `DrbdOptions/AutoEvictAfterTime` - long
         *
         *         Time a node can be offline before it is declared EVICTED in minutes
         *
         *     - `DrbdOptions/AutoEvictAllowEviction` - boolean_true_false
         *
         *         If set to true on a node, it cannot be evicted anymore
         *
         *     - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name for writecache
         *
         *     - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the writecache in % (0-100) or KiB otherwise
         *
         *     - `Writecache/Options/StartSector` - long
         *
         *         offset from the start of cache device in 512-byte sectors
         *
         *     - `Writecache/Options/HighWatermark` - long
         *
         *         start writeback when the number of used blocks reach this watermark
         *
         *     - `Writecache/Options/LowWatermark` - long
         *
         *         stop writeback when the number of used blocks drops below this watermark
         *
         *     - `Writecache/Options/WritebackJobs` - long
         *
         *         limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
         *
         *     - `Writecache/Options/AutocommitBlocks` - long
         *
         *         when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
         *
         *     - `Writecache/Options/AutocommitTime` - long
         *
         *         autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
         *
         *     - `Writecache/Options/Fua` - enum
         *
         *         "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
         *
         *         * On
         *         * Off
         *
         *     - `Writecache/Options/Additional` - string
         *
         *         Additional arguments passed through
         *
         *     - `Cache/OpMode` - enum
         *
         *         Operation mode
         *
         *         * writeback
         *         * writethrough
         *         * passthrough
         *
         *     - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
         *
         *     - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the cache in % (0-100) or KiB otherwise.
         *
         *     - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Name of the storage pool used for the cache cache device
         *
         *     - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the cache in % (0-100) or KiB otherwise.
         *
         *     - `Cache/Blocksize` - long
         *
         *         Block size
         *
         *     - `Cache/Policy` - enum
         *
         *         Replacemant policy
         *
         *         * mq
         *         * smq
         *         * cleaner
         *
         *     - `StorDriver/LvcreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'lvcreate ... ' command
         *
         *     - `StorDriver/ZfscreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'zfs create ... ' command
         *
         *     - `StorDriver/Openflex/ApiHost` - regex[`.+`]
         *
         *         Openflex API host name
         *
         *     - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
         *
         *         Openflex API port
         *
         *     - `StorDriver/Openflex/UserName` - regex[`.+`]
         *
         *         Openflex user name
         *
         *     - `StorDriver/Openflex/UserPassword` - regex[`.+`]
         *
         *         Openflex password
         *
         *     - `StorDriver/Openflex/StorDev` - regex[`.+`]
         *
         *         Openflex storage device
         *
         *     - `StorDriver/Openflex/StorDevHost` - regex[`.+`]
         *
         *         Openflex storage device host
         *
         *     - `StorDriver/Openflex/JobWaitDelay` - regex[`[0-9]+`]
         *
         *         Delay in milliseconds linstor waits between fetching the job status
         *
         *     - `StorDriver/Openflex/JobWaitMaxCount` - regex[`[0-9]+`]
         *
         *         Maximum retries with wait delay until openflex fails
         *
         *     - `Autoplacer/MaxThroughput` - long
         *
         *         The maximum throughput the given storage pool is capable of.
         *
         *     - `DrbdProxy/AutoEnable` - boolean_true_false
         *     - `Site` - string
         *     - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
         *
         *         Allows this resource to be cleaned up after toggle-disk + resync is finished
         *
         */
        put: operations["nodeModify"];
        post?: never;
        /**
         * delete a node
         * @description Delete a node from Linstor
         */
        delete: operations["nodeDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all node properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given node.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/lost": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * delete an unrecoverable node
         * @description Delete an unrecoverable node
         */
        delete: operations["nodeLost"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/reconnect": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * reconnect a node to the controller
         * @description Reconnect a node to the controller
         */
        put: operations["nodeReconnect"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/net-interfaces": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        /**
         * return the list of net-interfaces
         * @description Returns the list of netinterfaces for this node
         */
        get: operations["netinterfaceList"];
        put?: never;
        /**
         * create a netinterface on a node
         * @description Create a netinterface on a node
         *
         *     If satellite_port and satellite_encryption_type are given
         *     the netinterface can also work as connection to the controller
         *
         */
        post: operations["netinterfaceCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/net-interfaces/{netinterface}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description netinterface name to use */
                netinterface: components["parameters"]["NetInterface"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a netinterface from a node
         * @description Modify a netinterface from a node
         */
        put: operations["netinterfaceModified"];
        post?: never;
        /**
         * delete a netinterface from a node
         * @description Delete a netinterface from a node
         */
        delete: operations["netinterfaceDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/storage-pools": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        /**
         * lists all storage pools for a node
         * @description Lists all storage pools of a node
         */
        get: operations["nodeStoragePoolList"];
        put?: never;
        /**
         * creates a new storage pool on this node
         * @description Creates a new storage pool on this node.
         *
         *     `provider_kind` has to be specified and additional to that
         *     the linked `StorDriver` property that has the value to the backing pool:
         *
         *       * `LVM`: `StorDriver/LvmVg`
         *       * `LVM_THIN`: `StorDriver/LvmVg` and `StorDriver/ThinPool`
         *       * `ZFS`: `StorDriver/ZPool`
         *       * `ZFS_THIN`: `StorDriver/ZPoolThin`
         *       * `DISKLESS`: Does not need a property as it has no backing pool
         *
         */
        post: operations["nodeStoragePoolCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/storage-pools/{storagepool}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a storage pool
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `StorDriver/StorPoolName` - regex[`[a-zA-Z0-9_/-]+`]
         *     - `StorDriver/LvmVg` - regex[`[a-zA-Z0-9_-]+`]
         *     - `StorDriver/ThinPool` - regex[`[a-zA-Z0-9_-]+`]
         *     - `StorDriver/ZPool` - regex[`[a-zA-Z0-9_/-]+`]
         *     - `StorDriver/ZPoolThin` - regex[`[a-zA-Z0-9_/-]+`]
         *     - `StorDriver/FileDir` - regex[`.*`]
         *     - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Preferred network interface to use
         *
         *     - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Preferred network interface to use
         *
         *     - `StorDriver/LvcreateType` - enum
         *         * linear
         *         * striped
         *         * mirror
         *         * raid0
         *         * raid1
         *         * raid4
         *         * raid5
         *         * raid6
         *         * raid10
         *         * lzma
         *         * lz4
         *
         *     - `StorDriver/LvcreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'lvcreate ... ' command
         *
         *     - `StorDriver/ZfscreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'zfs create ... ' command
         *
         *     - `StorDriver/WaitTimeoutAfterCreate` - regex[`[0-9]+`]
         *     - `sys/fs/blkio_throttle_read` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
         *
         *     - `sys/fs/blkio_throttle_write` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
         *
         *     - `sys/fs/blkio_throttle_read_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
         *
         *     - `sys/fs/blkio_throttle_write_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
         *
         *     - `StorDriver/Openflex/ApiHost` - regex[`.+`]
         *
         *         Openflex API host name
         *
         *     - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
         *
         *         Openflex API port
         *
         *     - `StorDriver/Openflex/UserName` - regex[`.+`]
         *
         *         Openflex user name
         *
         *     - `StorDriver/Openflex/UserPassword` - regex[`.+`]
         *
         *         Openflex password
         *
         *     - `StorDriver/Openflex/StorDev` - regex[`.+`]
         *
         *         Openflex storage device
         *
         *     - `StorDriver/Openflex/StorDevHost` - regex[`.+`]
         *
         *         Openflex storage device host
         *
         *     - `StorDriver/Openflex/StorPool` - regex[`[0-9]+`]
         *
         *         Openflex storage pool name
         *
         *     - `Autoplacer/MaxThroughput` - long
         *
         *         The maximum throughput the given storage pool is capable of.
         *
         */
        put: operations["nodeStoragePoolModify"];
        post?: never;
        /**
         * delete a storage pool
         * @description Delete a storage pool
         */
        delete: operations["nodeStoragePoolDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/storage-pools/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        /**
         * List all storage-pool properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given storage pool on a particular node.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description node to use */
                    node: components["parameters"]["Node"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/restore": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * restore node
         * @description restore an evicted node
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description node to use */
                    node: components["parameters"]["Node"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["NodeRestore"];
                };
            };
            responses: {
                /** @description node restored */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/config": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        /**
         * show satellite config
         * @description Show Satellite config
         *
         */
        get: operations["SatelliteConfig"];
        /** modify satellite config */
        put: operations["StltSetConfig"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/{node}/evacuate": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * evacuates the node
         * @description Evacuates DRBD resources from the given node to other available nodes
         *     and deletes the evacuated resources once the sync is complete. Additionally
         *     sets the Node into EVACUATE state (no new resources allowed)
         *
         */
        put: operations["nodeEvacuate"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/nodes/ebs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * add an EBS (special) node to Linstor
         * @description Adds an EBS node to Linstor
         */
        post: operations["nodeAddEbs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/node-connections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all node connections
         * @description List all node connections resource
         */
        get: operations["nodeConnectionsList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/node-connections/{node_a}/{node_b}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a node connection
         * @description Sets or modifies properties
         *
         */
        put: operations["nodeConnectionModify"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * lists all resource-definitions
         * @description Lists all resource definitions.
         *
         *     A single resource definition can be queried by adding its name
         *     to the resource string like:
         *
         *     /v1/resource-definitions/rsc1
         *
         */
        get: operations["resourceDefinitionList"];
        put?: never;
        /**
         * add a resource-definition
         * @description Adds a resource-definition.
         *
         *     Only required property is the name of the resource definition.
         *     All other properties are optional.
         *
         */
        post: operations["resourceDefinitionCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/stats/resource-definitions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return stats of all resource definitions.
         * @description Returns a resource definition stats object.
         *
         */
        get: operations["resourceDefinitionStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a resource-definition
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use.
         *
         *     - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use for external metadata.
         *
         *     - `PeerSlotsNewResource` - range[`1-31`]
         *
         *         DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
         *
         *     - `DrbdProxy/CompressionType` - enum
         *         * zlib
         *         * lzma
         *         * lz4
         *         * zstd
         *
         *     - `DrbdOptions/AutoEvictMinReplicaCount` - long
         *
         *         The minimum amount of replicas that should be present for a resource at all times.
         *
         *     - `FileSystem/Type` - enum
         *
         *         File system type to use
         *
         *         * ext4
         *         * xfs
         *
         *     - `FileSystem/MkfsParams` - string
         *
         *         Additional parameters for the mkfs command
         *
         *     - `NVMe/TRType` - enum
         *
         *         NVMe transportion type
         *
         *         * rdma
         *         * tcp
         *
         *     - `NVMe/Port` - range[`1-65535`]
         *
         *         NVMe port
         *
         *     - `StorDriver/LvcreateType` - enum
         *         * linear
         *         * striped
         *         * mirror
         *         * raid0
         *         * raid1
         *         * raid4
         *         * raid5
         *         * raid6
         *         * raid10
         *         * lzma
         *         * lz4
         *
         *     - `StorDriver/LvcreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'lvcreate ... ' command
         *
         *     - `StorDriver/ZfscreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'zfs create ... ' command
         *
         *     - `sys/fs/blkio_throttle_read` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
         *
         *     - `sys/fs/blkio_throttle_write` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
         *
         *     - `sys/fs/blkio_throttle_read_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
         *
         *     - `sys/fs/blkio_throttle_write_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
         *
         *     - `DrbdOptions/auto-quorum` - enum
         *
         *         Enables automatic setting of the 'quroum' and 'on-no-quroum' property
         *
         *         * io-error
         *         * suspend-io
         *         * disabled
         *
         *     - `DrbdOptions/auto-add-quorum-tiebreaker` - boolean_true_false
         *
         *         Enables automatic management (creation and deletion) of tie breaking resource
         *
         *     - `DrbdOptions/auto-diskful` - long
         *
         *         Makes a resource diskful if it was continously diskless primary for X minutes
         *
         *     - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
         *
         *         Allows this resource to be cleaned up after toggle-disk + resync is finished
         *
         *     - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name for writecache
         *
         *     - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the writecache in % (0-100) or KiB otherwise
         *
         *     - `Writecache/Options/StartSector` - long
         *
         *         offset from the start of cache device in 512-byte sectors
         *
         *     - `Writecache/Options/HighWatermark` - long
         *
         *         start writeback when the number of used blocks reach this watermark
         *
         *     - `Writecache/Options/LowWatermark` - long
         *
         *         stop writeback when the number of used blocks drops below this watermark
         *
         *     - `Writecache/Options/WritebackJobs` - long
         *
         *         limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
         *
         *     - `Writecache/Options/AutocommitBlocks` - long
         *
         *         when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
         *
         *     - `Writecache/Options/AutocommitTime` - long
         *
         *         autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
         *
         *     - `Writecache/Options/Fua` - enum
         *
         *         "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
         *
         *         * On
         *         * Off
         *
         *     - `Writecache/Options/Additional` - string
         *
         *         Additional arguments passed through
         *
         *     - `Cache/OpMode` - enum
         *
         *         Operation mode
         *
         *         * writeback
         *         * writethrough
         *         * passthrough
         *
         *     - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
         *
         *     - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the cache in % (0-100) or KiB otherwise.
         *
         *     - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Name of the storage pool used for the cache cache device
         *
         *     - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the cache in % (0-100) or KiB otherwise.
         *
         *     - `Cache/Blocksize` - long
         *
         *         Block size
         *
         *     - `Cache/Policy` - enum
         *
         *         Replacemant policy
         *
         *         * mq
         *         * smq
         *         * cleaner
         *
         *     - `SnapshotShipping/SourceNode` - string
         *
         *         Node name of the snapshot shipping source
         *
         *     - `SnapshotShipping/TargetNode` - string
         *
         *         Node name of the snapshot shipping target
         *
         *     - `SnapshotShipping/RunEvery` - long
         *
         *         Runs every X minutes an auto-snapshot-shipping unless the current snapshot-shipping is still running. In this case a new one will be started asap.
         *
         *     - `SnapshotShipping/Keep` - long
         *
         *         Keeps the last X shipped snapshots. Removing this property or having a value <= 0 disables auto-cleanup, all auto-snapshots will be kept
         *
         *     - `AutoSnapshot/RunEvery` - long
         *
         *         Runs every X minutes an snapshot-creation. Removing this property or having a value <= 0 disables auto-snapshotting.
         *
         *     - `AutoSnapshot/Keep` - long
         *
         *         Keeps the last X auto-snapshots. Removing this property or having a value <= 0 disables auto-cleanup, all auto-snapshots will be kept
         *
         *     - `AutoSnapshot/NextAutoId` - long
         *
         *         The next ID to try for auto-snapshots
         *
         *     - `DrbdOptions/Disk/on-io-error` - enum
         *         * pass_on
         *         * call-local-io-error
         *         * detach
         *
         *     - `DrbdOptions/Disk/disk-barrier` - boolean
         *     - `DrbdOptions/Disk/disk-flushes` - boolean
         *     - `DrbdOptions/Disk/disk-drain` - boolean
         *     - `DrbdOptions/Disk/md-flushes` - boolean
         *     - `DrbdOptions/Disk/resync-after` - string
         *     - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
         *     - `DrbdOptions/Disk/al-updates` - boolean
         *     - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
         *     - `DrbdOptions/Disk/disable-write-same` - boolean
         *     - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
         *     - `DrbdOptions/Disk/read-balancing` - enum
         *         * prefer-local
         *         * prefer-remote
         *         * round-robin
         *         * least-pending
         *         * when-congested-remote
         *         * 32K-striping
         *         * 64K-striping
         *         * 128K-striping
         *         * 256K-striping
         *         * 512K-striping
         *         * 1M-striping
         *
         *     - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
         *     - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
         *     - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
         *     - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
         *     - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
         *     - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
         *     - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
         *     - `DrbdOptions/PeerDevice/bitmap` - boolean
         *     - `DrbdOptions/Resource/cpu-mask` - string
         *     - `DrbdOptions/Resource/on-no-data-accessible` - enum
         *         * io-error
         *         * suspend-io
         *
         *     - `DrbdOptions/Resource/auto-promote` - boolean
         *     - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
         *     - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
         *     - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
         *     - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
         *     - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
         *     - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
         *     - `DrbdOptions/Resource/quorum` - enum [`1-32`]
         *         * off
         *         * majority
         *         * all
         *
         *     - `DrbdOptions/Resource/on-no-quorum` - enum
         *         * io-error
         *         * suspend-io
         *
         *     - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
         *         * off
         *         * majority
         *         * all
         *
         *     - `DrbdOptions/Net/transport` - string
         *     - `DrbdOptions/Net/protocol` - enum
         *         * A
         *         * B
         *         * C
         *
         *     - `DrbdOptions/Net/timeout` - range[`1-600`]
         *     - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
         *     - `DrbdOptions/Net/connect-int` - range[`1-120`]
         *     - `DrbdOptions/Net/ping-int` - range[`1-120`]
         *     - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Net/ko-count` - range[`0-200`]
         *     - `DrbdOptions/Net/allow-two-primaries` - boolean
         *     - `DrbdOptions/Net/cram-hmac-alg` - string
         *     - `DrbdOptions/Net/shared-secret` - string
         *     - `DrbdOptions/Net/after-sb-0pri` - enum
         *         * disconnect
         *         * discard-younger-primary
         *         * discard-older-primary
         *         * discard-zero-changes
         *         * discard-least-changes
         *         * discard-local
         *         * discard-remote
         *
         *     - `DrbdOptions/Net/after-sb-1pri` - enum
         *         * disconnect
         *         * consensus
         *         * discard-secondary
         *         * call-pri-lost-after-sb
         *         * violently-as0p
         *
         *     - `DrbdOptions/Net/after-sb-2pri` - enum
         *         * disconnect
         *         * call-pri-lost-after-sb
         *         * violently-as0p
         *
         *     - `DrbdOptions/Net/always-asbp` - boolean
         *     - `DrbdOptions/Net/rr-conflict` - enum
         *         * disconnect
         *         * call-pri-lost
         *         * violently
         *         * retry-connect
         *
         *     - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
         *     - `DrbdOptions/Net/data-integrity-alg` - string
         *     - `DrbdOptions/Net/tcp-cork` - boolean
         *     - `DrbdOptions/Net/on-congestion` - enum
         *         * block
         *         * pull-ahead
         *         * disconnect
         *
         *     - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
         *     - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
         *     - `DrbdOptions/Net/csums-alg` - string
         *     - `DrbdOptions/Net/csums-after-crash-only` - boolean
         *     - `DrbdOptions/Net/verify-alg` - string
         *     - `DrbdOptions/Net/use-rle` - boolean
         *     - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
         *     - `DrbdOptions/Net/fencing` - enum
         *         * dont-care
         *         * resource-only
         *         * resource-and-stonith
         *
         *     - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
         *     - `DrbdOptions/Net/allow-remote-read` - boolean
         *     - `DrbdOptions/Handlers/after-resync-target` - string
         *     - `DrbdOptions/Handlers/before-resync-target` - string
         *     - `DrbdOptions/Handlers/before-resync-source` - string
         *     - `DrbdOptions/Handlers/out-of-sync` - string
         *     - `DrbdOptions/Handlers/quorum-lost` - string
         *     - `DrbdOptions/Handlers/fence-peer` - string
         *     - `DrbdOptions/Handlers/unfence-peer` - string
         *     - `DrbdOptions/Handlers/initial-split-brain` - string
         *     - `DrbdOptions/Handlers/local-io-error` - string
         *     - `DrbdOptions/Handlers/pri-lost` - string
         *     - `DrbdOptions/Handlers/pri-lost-after-sb` - string
         *     - `DrbdOptions/Handlers/pri-on-incon-degr` - string
         *     - `DrbdOptions/Handlers/split-brain` - string
         *
         */
        put: operations["resourceDefinitionModify"];
        post?: never;
        /**
         * delete a resource-definition
         * @description Delete a resource-definition
         */
        delete: operations["resourceDefinitionDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/clone": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * clones a resource definition with all resources
         * @description Clones the resource definition with all resources and volume with the current data and
         *     the best/fastest possible clone method. Clone method depends on storage pool type:
         *       * LVM -> dd
         *       * LVM-thin -> snapshot -> logical volume
         *       * ZFS -> zfs send/recieve
         *
         */
        post: operations["resourceDefinitionClone"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/clone/{resourceClone}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description resource clone name */
                resourceClone: components["parameters"]["ResourceClone"];
            };
            cookie?: never;
        };
        /**
         * retrieve status of the current clone process
         * @description Get info of the current clone status. e.g. if completed.
         *
         */
        get: operations["resourceDefinitionCloneStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/sync-status": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * check if a resource is currently synced on all nodes
         * @description Get info if the resource is synced on all nodes
         *
         */
        get: operations["resourceDefinitionSyncStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/files/{extFileName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /**
                 * @description Name of an external file. Must be an absolute path in URL-encoding
                 * @example %2Fetc%2Fsome.conf
                 */
                extFileName: components["parameters"]["ExternalFileName"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * enables deployment of an external file for the given resource
         * @description Enables deployment of a previously created external file for a resource definition.
         *     This has the effect that the external file will be created in a host's file
         *     system whenever `resource` is deployed on that host.
         *
         */
        post: operations["resourceDeploy"];
        /**
         * disables deployment of an external file for the given resource
         * @description Removes the requirement from this resource definition to create the given external file.
         *     If nothing requires the external file to exist on a satellite, the satellite also will delete the
         *     external file from the host's file system.
         *
         */
        delete: operations["resourceUndeploy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all resource-definition properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given resource definition.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/volume-definitions": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * lists all volume-definitions
         * @description Lists all volume definitions.
         *
         *     A single volume definition can be queried by adding its name
         *     to the resource string like:
         *
         *     /v1/resource-definitions/rsc1/volume-definitions/0
         *
         */
        get: operations["volumeDefinitionList"];
        put?: never;
        /**
         * add a volume-definition to a resource
         * @description Adds a volume-definition.
         *
         *     Required properties is only `size`, all other will be auto generated if not given.
         *
         */
        post: operations["volumeDefinitionCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/volume-definitions/{volume_number}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a volume-definition
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use.
         *
         *     - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use for external metadata.
         *
         *     - `OverrideVlmId` - regex[`.*`]
         *
         *         Overwrites the generated '<resource-name>_<5 digit volume number>' volume name for migration purposes
         *
         *     - `FileSystem/Type` - enum
         *
         *         File system type to use
         *
         *         * ext4
         *         * xfs
         *
         *     - `FileSystem/MkfsParams` - string
         *
         *         Additional parameters for the mkfs command
         *
         *     - `StorDriver/LvcreateType` - enum
         *         * linear
         *         * striped
         *         * mirror
         *         * raid0
         *         * raid1
         *         * raid4
         *         * raid5
         *         * raid6
         *         * raid10
         *         * lzma
         *         * lz4
         *
         *     - `StorDriver/LvcreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'lvcreate ... ' command
         *
         *     - `StorDriver/ZfscreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'zfs create ... ' command
         *
         *     - `DrbdCurrentGi` - regex[`[a-fA-F0-9]{16}`]
         *
         *         Initial DRBD generation id, if initial sync is skipped, this ID will be set
         *
         *     - `sys/fs/blkio_throttle_read` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
         *
         *     - `sys/fs/blkio_throttle_write` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
         *
         *     - `sys/fs/blkio_throttle_read_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
         *
         *     - `sys/fs/blkio_throttle_write_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
         *
         *     - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name for writecache
         *
         *     - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the writecache in % (0-100) or KiB otherwise
         *
         *     - `Writecache/Options/StartSector` - long
         *
         *         offset from the start of cache device in 512-byte sectors
         *
         *     - `Writecache/Options/HighWatermark` - long
         *
         *         start writeback when the number of used blocks reach this watermark
         *
         *     - `Writecache/Options/LowWatermark` - long
         *
         *         stop writeback when the number of used blocks drops below this watermark
         *
         *     - `Writecache/Options/WritebackJobs` - long
         *
         *         limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
         *
         *     - `Writecache/Options/AutocommitBlocks` - long
         *
         *         when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
         *
         *     - `Writecache/Options/AutocommitTime` - long
         *
         *         autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
         *
         *     - `Writecache/Options/Fua` - enum
         *
         *         "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
         *
         *         * On
         *         * Off
         *
         *     - `Writecache/Options/Additional` - string
         *
         *         Additional arguments passed through
         *
         *     - `Cache/OpMode` - enum
         *
         *         Operation mode
         *
         *         * writeback
         *         * writethrough
         *         * passthrough
         *
         *     - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
         *
         *     - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the cache in % (0-100) or KiB otherwise.
         *
         *     - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Name of the storage pool used for the cache cache device
         *
         *     - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the cache in % (0-100) or KiB otherwise.
         *
         *     - `Cache/Blocksize` - long
         *
         *         Block size
         *
         *     - `Cache/Policy` - enum
         *
         *         Replacemant policy
         *
         *         * mq
         *         * smq
         *         * cleaner
         *
         *     - `DrbdOptions/Disk/on-io-error` - enum
         *         * pass_on
         *         * call-local-io-error
         *         * detach
         *
         *     - `DrbdOptions/Disk/disk-barrier` - boolean
         *     - `DrbdOptions/Disk/disk-flushes` - boolean
         *     - `DrbdOptions/Disk/disk-drain` - boolean
         *     - `DrbdOptions/Disk/md-flushes` - boolean
         *     - `DrbdOptions/Disk/resync-after` - string
         *     - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
         *     - `DrbdOptions/Disk/al-updates` - boolean
         *     - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
         *     - `DrbdOptions/Disk/disable-write-same` - boolean
         *     - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
         *     - `DrbdOptions/Disk/read-balancing` - enum
         *         * prefer-local
         *         * prefer-remote
         *         * round-robin
         *         * least-pending
         *         * when-congested-remote
         *         * 32K-striping
         *         * 64K-striping
         *         * 128K-striping
         *         * 256K-striping
         *         * 512K-striping
         *         * 1M-striping
         *
         *     - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
         *
         */
        put: operations["volumeDefinitionModify"];
        post?: never;
        /**
         * delete a volume-definition
         * @description Delete a volume-definition
         */
        delete: operations["volumeDefinitionDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/volume-definitions/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * List all volume-definition properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given volume definition of a particular resource.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description resource to use */
                    resource: components["parameters"]["Resource"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/volume-definitions/{volume_number}/encryption-passphrase": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify encryption passphrase for a volume definition
         * @description Sets a new user provied encryption passphrase
         */
        put: operations["volumeDefinitionModifyPassphrase"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * lists all resources for a resource-definition
         * @description Lists all resources for a resource-definition.
         *
         *     A single resource can be queried by adding its name
         *     to the resource string like:
         *
         *     /v1/resource-definitions/rsc1/resources/nodeA
         *
         */
        get: operations["resourceList"];
        put?: never;
        /**
         * create one or more resources.
         * @description Adds one or more resource(s).
         *
         */
        post: operations["resourceCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a resource
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use.
         *
         *     - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use for external metadata.
         *
         *     - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Preferred network interface to use
         *
         *     - `PeerSlots` - range[`1-31`]
         *
         *         DRBD peer slots present on resource
         *
         *     - `FileSystem/Type` - enum
         *
         *         File system type to use
         *
         *         * ext4
         *         * xfs
         *
         *     - `FileSystem/MkfsParams` - string
         *
         *         Additional parameters for the mkfs command
         *
         *     - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Preferred network interface to use
         *
         *     - `sys/fs/blkio_throttle_read` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
         *
         *     - `sys/fs/blkio_throttle_write` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
         *
         *     - `sys/fs/blkio_throttle_read_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
         *
         *     - `sys/fs/blkio_throttle_write_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
         *
         *     - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
         *
         *         Allows this resource to be cleaned up after toggle-disk + resync is finished
         *
         *
         */
        put: operations["resourceModify"];
        /**
         * create a resource on a node
         * @description Adds a resource on a node.
         *
         *     To use a specific storage pool add the `StorPoolName` property
         *     and use the storage pool name as value.
         *     If the `StorPoolName` property is not set, the `DfltStorPool` will be used.
         *
         *     To create a diskless resource you have to set the "DISKLESS" flag in the flags list.
         *     ```
         *     {
         *       "resource": {
         *         "flags": ["DISKLESS"]
         *       }
         *     }
         *     ```
         *
         */
        post: operations["resourceCreateOnNode"];
        /**
         * delete a resource
         * @description Delete a resource on a node
         */
        delete: operations["resourceDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/make-available": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * creates the resource if not already deployed
         * @description Adds a resource on a node if not already deployed.
         *
         *     New resources will be diskless, if possible. To force creation of
         *     a diskful resource, set `diskful` to `true` in the request body.
         *
         *     Optionally, you can override the layer stack for the created resource.
         *     If not given, the default configuration for the resource definition is
         *     used.
         *
         *     The storage pool will be selected by the autoplacer.
         *
         */
        post: operations["resourceMakeAvailableOnNode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/activate": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * activates the resource
         * @description Activates the given resource if possible
         */
        post: operations["ActivateRsc"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/deactivate": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * deactivates the resource
         * @description Deactivates the given resource if possible
         */
        post: operations["DeactivateRsc"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * List all resource properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given resource in a particular resource definition.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description resource to use */
                    resource: components["parameters"]["Resource"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/volumes": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        /**
         * lists all volumes of a resources
         * @description Lists all volumes for a resource-definition.
         *
         *     A single volume can be queried by adding its volume number
         *     to the resource string like:
         *
         *     /v1/resource-definitions/rsc1/resources/nodeA/volumes/0
         *
         */
        get: operations["resourceVolumeList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/volumes/{volume_number}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a volume
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `sys/fs/blkio_throttle_read` - number
         *     - `sys/fs/blkio_throttle_write` - number
         *
         */
        put: operations["volumeModify"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/volumes/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * List all volume properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given volume of a particular resource on a particular node.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description node to use */
                    node: components["parameters"]["Node"];
                    /** @description resource to use */
                    resource: components["parameters"]["Resource"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskless": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * toggle a resource to diskless
         * @description toggle a resource to a diskless resource
         */
        put: operations["resourceToggleDiskless"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskless/{disklesspool}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description diskless pool to use. */
                disklesspool: string;
            };
            cookie?: never;
        };
        get?: never;
        /**
         * toggle a resource to diskless resource
         * @description toggle a resource to a diskless.
         *
         */
        put: operations["resourceToggleDisklessDisklesspool"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskful": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * toggle a resource to a diskful resource
         * @description toggle a resource to a diskful resource using the default storage pool
         *
         */
        put: operations["resourceToggleDiskful"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskful/{storagepool}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * toggle a resource to a diskful resource
         * @description toggle a resource to a diskful resource
         */
        put: operations["resourceToggleDiskfulStoragepool"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/migrate-disk/{fromnode}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description node that should be deleted after the successful migrate */
                fromnode: string;
            };
            cookie?: never;
        };
        get?: never;
        /**
         * migrate a resource to another node
         * @description migrate a resource to another node without reducing the redundancy count
         *
         */
        put: operations["resourceMigrateDisk"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resources/{node}/migrate-disk/{fromnode}/{storagepool}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description node that should be deleted after the successful migrate */
                fromnode: string;
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * migrate a resource to another node
         * @description migrate a resource to another node without reducing the redundency count
         *
         */
        put: operations["resourceMigrateDiskStoragepool"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/autoplace": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * autoplace resource
         * @description Auto place the resource on the specified place_count redundency.
         *     If place_count isn't given 2 is the default.
         *
         */
        post: operations["resourceAutoplace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resource-connections": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * list all resource connections for resource
         * @description List all resource connections for resource
         */
        get: operations["resourceConnectionsList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resource-connections/{node_a}/{node_b}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        /**
         * show the specified resource connection
         * @description show the specified resource connection
         */
        get: operations["resourceConnectionList"];
        /**
         * modify a resource connection
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
         *     - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
         *     - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
         *     - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
         *     - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
         *     - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
         *     - `DrbdOptions/PeerDevice/bitmap` - boolean
         *     - `DrbdOptions/Net/transport` - string
         *     - `DrbdOptions/Net/protocol` - enum
         *         * A
         *         * B
         *         * C
         *
         *     - `DrbdOptions/Net/timeout` - range[`1-600`]
         *     - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
         *     - `DrbdOptions/Net/connect-int` - range[`1-120`]
         *     - `DrbdOptions/Net/ping-int` - range[`1-120`]
         *     - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Net/ko-count` - range[`0-200`]
         *     - `DrbdOptions/Net/allow-two-primaries` - boolean
         *     - `DrbdOptions/Net/cram-hmac-alg` - string
         *     - `DrbdOptions/Net/shared-secret` - string
         *     - `DrbdOptions/Net/after-sb-0pri` - enum
         *         * disconnect
         *         * discard-younger-primary
         *         * discard-older-primary
         *         * discard-zero-changes
         *         * discard-least-changes
         *         * discard-local
         *         * discard-remote
         *
         *     - `DrbdOptions/Net/after-sb-1pri` - enum
         *         * disconnect
         *         * consensus
         *         * discard-secondary
         *         * call-pri-lost-after-sb
         *         * violently-as0p
         *
         *     - `DrbdOptions/Net/after-sb-2pri` - enum
         *         * disconnect
         *         * call-pri-lost-after-sb
         *         * violently-as0p
         *
         *     - `DrbdOptions/Net/always-asbp` - boolean
         *     - `DrbdOptions/Net/rr-conflict` - enum
         *         * disconnect
         *         * call-pri-lost
         *         * violently
         *         * retry-connect
         *
         *     - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
         *     - `DrbdOptions/Net/data-integrity-alg` - string
         *     - `DrbdOptions/Net/tcp-cork` - boolean
         *     - `DrbdOptions/Net/on-congestion` - enum
         *         * block
         *         * pull-ahead
         *         * disconnect
         *
         *     - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
         *     - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
         *     - `DrbdOptions/Net/csums-alg` - string
         *     - `DrbdOptions/Net/csums-after-crash-only` - boolean
         *     - `DrbdOptions/Net/verify-alg` - string
         *     - `DrbdOptions/Net/use-rle` - boolean
         *     - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
         *     - `DrbdOptions/Net/fencing` - enum
         *         * dont-care
         *         * resource-only
         *         * resource-and-stonith
         *
         *     - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
         *     - `DrbdOptions/Net/allow-remote-read` - boolean
         *
         */
        put: operations["resourceConnectionModify"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/resource-connections/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * List all resource-connection properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given connection of a particular resource.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description resource to use */
                    resource: components["parameters"]["Resource"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/snapshots": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * list snapshots
         * @description List snapshots for a resource
         */
        get: operations["resourceSnapshotsList"];
        put?: never;
        /**
         * create a snapshot
         * @description Create a snapshot for a resource
         */
        post: operations["resourceSnapshotCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/snapshots/{snapshot}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list a specific snapshot
         * @description List the given snapshot for a resource
         */
        get: operations["resourceSnapshotList"];
        put?: never;
        post?: never;
        /**
         * delete a snapshot
         * @description Delete a snapshot
         */
        delete: operations["resourceSnapshotDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/snapshot-restore-resource/{snapshot}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Snapshot name to use */
                snapshot: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * restore a snapshot
         * @description Restore a snapshot to a new resource
         */
        post: operations["resourceSnapshotRestore"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/snapshot-restore-volume-definition/{snapshot}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Snapshot name to use */
                snapshot: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * restore a snapshot volume definition
         * @description Restore a snapshot volume definition to a new resource
         */
        post: operations["resourceSnapshotsRestoreVolumeDefinition"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/snapshot-rollback/{snapshot}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Snapshot name to use */
                snapshot: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * rollback a snapshot
         * @description Rollback a resource to the snapshot state
         */
        post: operations["resourceSnapshotRollback"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/snapshot-shipping": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * ship a snapshot
         * @description Transfers the resource from one node to another based on snapshot-shipping
         */
        post: operations["snapshotShipping"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * lists all resource-groups
         * @description Lists all resource groups.
         *
         *     A single resource group can be queried by adding its name
         *     to the resource string like:
         *
         *     /v1/resource-groups/rscgrp1
         *
         */
        get: operations["resourceGroupList"];
        put?: never;
        /**
         * add a resource-group
         * @description Adds a resource-group.
         *
         *     Only required property is the name of the resource group.
         *     All other properties are optional.
         *
         */
        post: operations["resourceGroupCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/stats/resource-groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return stats of all resource groups.
         * @description Returns a resource group stats object.
         *
         */
        get: operations["resourceGroupStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/{resource_group}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a resource-group
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use.
         *
         *     - `PeerSlotsNewResource` - range[`1-31`]
         *
         *         DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
         *
         *     - `DrbdProxy/CompressionType` - enum
         *         * zlib
         *         * lzma
         *         * lz4
         *
         *     - `FileSystem/Type` - enum
         *
         *         File system type to use
         *
         *         * ext4
         *         * xfs
         *
         *     - `FileSystem/MkfsParams` - string
         *
         *         Additional parameters for the mkfs command
         *
         *     - `NVMe/enabled` - enum
         *         * rdma
         *         * tcp
         *
         *     - `NVMe/enabled` - range[`1-65535`]
         *     - `DrbdOptions/Disk/read-balancing` - enum
         *         * prefer-local
         *         * prefer-remote
         *         * round-robin
         *         * least-pending
         *         * when-congested-remote
         *         * 32K-striping
         *         * 64K-striping
         *         * 128K-striping
         *         * 256K-striping
         *         * 512K-striping
         *         * 1M-striping
         *
         *     - `DrbdOptions/Disk/on-io-error` - enum
         *         * pass_on
         *         * call-local-io-error
         *         * detach
         *
         *     - `DrbdOptions/Disk/disk-drain` - boolean
         *     - `DrbdOptions/Disk/resync-after` - string
         *     - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
         *     - `DrbdOptions/Disk/disable-write-same` - boolean
         *     - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
         *     - `DrbdOptions/Disk/disk-flushes` - boolean
         *     - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
         *     - `DrbdOptions/Disk/al-updates` - boolean
         *     - `DrbdOptions/Disk/md-flushes` - boolean
         *     - `DrbdOptions/Disk/disk-barrier` - boolean
         *     - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
         *     - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
         *     - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
         *     - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
         *     - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
         *     - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
         *     - `DrbdOptions/PeerDevice/bitmap` - boolean
         *     - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
         *     - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
         *     - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
         *         * off
         *         * majority
         *         * all
         *
         *     - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
         *     - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
         *     - `DrbdOptions/Resource/quorum` - enum [`1-32`]
         *         * off
         *         * majority
         *         * all
         *
         *     - `DrbdOptions/Resource/on-no-data-accessible` - enum
         *         * io-error
         *         * suspend-io
         *
         *     - `DrbdOptions/Resource/auto-promote` - boolean
         *     - `DrbdOptions/Resource/cpu-mask` - string
         *     - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
         *     - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
         *     - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
         *     - `DrbdOptions/Resource/on-no-quorum` - enum
         *         * io-error
         *         * suspend-io
         *
         *     - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
         *     - `DrbdOptions/Net/protocol` - enum
         *         * A
         *         * B
         *         * C
         *
         *     - `DrbdOptions/Net/allow-two-primaries` - boolean
         *     - `DrbdOptions/Net/after-sb-0pri` - enum
         *         * disconnect
         *         * discard-younger-primary
         *         * discard-older-primary
         *         * discard-zero-changes
         *         * discard-least-changes
         *         * discard-local
         *         * discard-remote
         *
         *     - `DrbdOptions/Net/ko-count` - range[`0-200`]
         *     - `DrbdOptions/Net/data-integrity-alg` - string
         *     - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
         *     - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Net/transport` - string
         *     - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
         *     - `DrbdOptions/Net/fencing` - enum
         *         * dont-care
         *         * resource-only
         *         * resource-and-stonith
         *
         *     - `DrbdOptions/Net/csums-alg` - string
         *     - `DrbdOptions/Net/always-asbp` - boolean
         *     - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
         *     - `DrbdOptions/Net/on-congestion` - enum
         *         * block
         *         * pull-ahead
         *         * disconnect
         *
         *     - `DrbdOptions/Net/ping-int` - range[`1-120`]
         *     - `DrbdOptions/Net/rr-conflict` - enum
         *         * disconnect
         *         * call-pri-lost
         *         * violently
         *
         *     - `DrbdOptions/Net/tcp-cork` - boolean
         *     - `DrbdOptions/Net/use-rle` - boolean
         *     - `DrbdOptions/Net/csums-after-crash-only` - boolean
         *     - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
         *     - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
         *     - `DrbdOptions/Net/cram-hmac-alg` - string
         *     - `DrbdOptions/Net/verify-alg` - string
         *     - `DrbdOptions/Net/shared-secret` - string
         *     - `DrbdOptions/Net/connect-int` - range[`1-120`]
         *     - `DrbdOptions/Net/timeout` - range[`1-600`]
         *     - `DrbdOptions/Net/after-sb-2pri` - enum
         *         * disconnect
         *         * call-pri-lost-after-sb
         *         * violently-as0p
         *
         *     - `DrbdOptions/Net/after-sb-1pri` - enum
         *         * disconnect
         *         * consensus
         *         * discard-secondary
         *         * call-pri-lost-after-sb
         *         * violently-as0p
         *
         *     - `DrbdOptions/Handlers/after-resync-target` - string
         *     - `DrbdOptions/Handlers/before-resync-target` - string
         *     - `DrbdOptions/Handlers/before-resync-source` - string
         *     - `DrbdOptions/Handlers/out-of-sync` - string
         *     - `DrbdOptions/Handlers/quorum-lost` - string
         *     - `DrbdOptions/Handlers/fence-peer` - string
         *     - `DrbdOptions/Handlers/unfence-peer` - string
         *     - `DrbdOptions/Handlers/initial-split-brain` - string
         *     - `DrbdOptions/Handlers/local-io-error` - string
         *     - `DrbdOptions/Handlers/pri-lost` - string
         *     - `DrbdOptions/Handlers/pri-lost-after-sb` - string
         *     - `DrbdOptions/Handlers/pri-on-incon-degr` - string
         *     - `DrbdOptions/Handlers/split-brain` - string
         *
         */
        put: operations["resourceGroupModify"];
        post?: never;
        /**
         * delete a resource-group
         * @description Delete a resource-group
         */
        delete: operations["resourceGroupDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all resource-group properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given resource group.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/{resource_group}/spawn": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * create a new resource-definition based on the given resource-group
         * @description Creates a new resource-definition and auto-deploys if configured to do so.
         *
         */
        post: operations["resourceGroupSpawn"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/{resource_group}/volume-groups": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        /**
         * lists all volume-groups
         * @description Lists all volume groups.
         *
         *     A single volume group can be queried by adding its name
         *     to the resource string like:
         *
         *     /v1/resource-groups/rscgrp1/volume-groups/0
         *
         */
        get: operations["volumeGroupList"];
        put?: never;
        /**
         * add a volume-group to a resource-group
         * @description Adds a volume-group.
         *
         */
        post: operations["volumeGroupCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/{resource_group}/volume-groups/{volume_number}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a volume-group
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name to use.
         *
         *     - `OverrideVlmId` - regex[`.*`]
         *
         *         Overwrites the generated '<resource-name>_<5 digit volume number>' volume name for migration purposes
         *
         *     - `AllowLargerVolumeSize` - boolean_true_false
         *
         *         Do not fail when the underlying volume is larger than expected
         *
         *     - `FileSystem/Type` - enum
         *
         *         File system type to use
         *
         *         * ext4
         *         * xfs
         *
         *     - `FileSystem/MkfsParams` - string
         *
         *         Additional parameters for the mkfs command
         *
         *     - `StorDriver/LvcreateType` - enum
         *         * linear
         *         * striped
         *         * mirror
         *         * raid0
         *         * raid1
         *         * raid4
         *         * raid5
         *         * raid6
         *         * raid10
         *         * lzma
         *         * lz4
         *
         *     - `DrbdCurrentGi` - regex[`[a-fA-F0-9]{16}`]
         *     - `DrbdOptions/Disk/read-balancing` - enum
         *         * prefer-local
         *         * prefer-remote
         *         * round-robin
         *         * least-pending
         *         * when-congested-remote
         *         * 32K-striping
         *         * 64K-striping
         *         * 128K-striping
         *         * 256K-striping
         *         * 512K-striping
         *         * 1M-striping
         *
         *     - `DrbdOptions/Disk/on-io-error` - enum
         *         * pass_on
         *         * call-local-io-error
         *         * detach
         *
         *     - `DrbdOptions/Disk/disk-drain` - boolean
         *     - `DrbdOptions/Disk/resync-after` - string
         *     - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
         *     - `DrbdOptions/Disk/disable-write-same` - boolean
         *     - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
         *     - `DrbdOptions/Disk/disk-flushes` - boolean
         *     - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
         *     - `DrbdOptions/Disk/al-updates` - boolean
         *     - `DrbdOptions/Disk/md-flushes` - boolean
         *     - `DrbdOptions/Disk/disk-barrier` - boolean
         *     - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
         *
         */
        put: operations["volumeGroupModify"];
        post?: never;
        /**
         * delete a volume-group
         * @description Delete a volume-group
         */
        delete: operations["volumeGroupDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/{resource_group}/volume-groups/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        /**
         * List all volume-group properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for any given volume group of a particular resource group.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description resource group to use */
                    resource_group: components["parameters"]["ResourceGroupName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/{resource_group}/query-max-volume-size": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        /**
         * query the maximum volume size from a given resource group
         * @deprecated
         * @description Query the maximum possible volume size storage pools
         */
        get: operations["queryMaxVolumeSizeFromRscGrp"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/{resource_group}/query-size-info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * query size information of the current resource group
         * @description Query size information like maximum volume size for the next
         *     spawn command. The result will include the selected storage pools.
         *
         */
        post: operations["querySizeInfo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/{resource_group}/adjust": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * adjusts (calls autoplace for) all resource-definitions of the given resource-group
         * @description Adjusts (calls autoplace for) all resource-definitions of the given resource-group
         *
         */
        post: operations["resourceGroupAdjust"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-groups/adjustall": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * adjusts (calls autoplace for) all resource-definitions of all resource-groups
         * @description Adjusts (calls autoplace for) all resource-definitions of all resource-groups
         *
         */
        post: operations["resourceGroupAdjustAll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/controller/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * lists all controller properties
         * @description Lists all controller properties.
         *
         */
        get: operations["controllerPropertyList"];
        put?: never;
        /**
         * sets or modifies controller properties
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `TcpPortAutoRange` - regex[`[0-9]+-[0-9]+`]
         *
         *         Range for auto-allocation of resource TCP ports
         *
         *     - `MinorNrAutoRange` - regex[`[0-9]+-[0-9]+`]
         *
         *         Range for auto-allocation of volume minor numbers
         *
         *     - `PeerSlotsNewResource` - range[`1-31`]
         *
         *         DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future
         *
         *     - `StorDriver/DMStats` - boolean_true_false
         *
         *         Enable dmstats on lvm create
         *
         *     - `REST/disable-http-metrics` - boolean_true_false
         *
         *         Disable Prometheus /metrics on HTTP, if HTTPS is enabled
         *
         *     - `DrbdOptions/AutoEvictAfterTime` - long
         *
         *         Time a node can be offline before it is declared EVICTED in minutes
         *
         *     - `DrbdOptions/AutoEvictMaxDisconnectedNodes` - range[`0-100`]
         *
         *         Percentage(0-100) of nodes that can disconnect at the same time without the controller stopping the max_offline_time timer
         *
         *     - `DrbdOptions/AutoEvictMinReplicaCount` - long
         *
         *         The minimum amount of replicas that should be present for a resource at all times.
         *
         *     - `DrbdOptions/AutoEvictAllowEviction` - boolean_true_false
         *
         *         If set to true on a node, it cannot be evicted anymore
         *
         *     - `NVMe/TRType` - enum
         *
         *         NVMe transportion type
         *
         *         * rdma
         *         * tcp
         *
         *     - `NVMe/Port` - range[`1-65535`]
         *
         *         NVMe port
         *
         *     - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Preferred network interface to use
         *
         *     - `StorDriver/WaitTimeoutAfterCreate` - regex[`[0-9]+`]
         *     - `sys/fs/blkio_throttle_read` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
         *
         *     - `sys/fs/blkio_throttle_write` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device
         *
         *     - `sys/fs/blkio_throttle_read_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_iops_device
         *
         *     - `sys/fs/blkio_throttle_write_iops` - long
         *
         *         Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_iops_device
         *
         *     - `SearchDomain` - string
         *
         *         Search domain node names, if no FQDN is given.
         *
         *     - `ExtCmdWaitTimeout` - long
         *
         *         Wait timeout for an external command in milliseconds
         *
         *     - `DrbdOptions/auto-quorum` - enum
         *
         *         Enables automatic setting of the 'quroum' and 'on-no-quroum' property
         *
         *         * io-error
         *         * suspend-io
         *         * disabled
         *
         *     - `DrbdOptions/auto-add-quorum-tiebreaker` - boolean_true_false
         *
         *         Enables automatic management (creation and deletion) of tie breaking resource
         *
         *     - `DrbdOptions/auto-diskful` - long
         *
         *         Makes a resource diskful if it was continously diskless primary for X minutes
         *
         *     - `DrbdOptions/auto-diskful-allow-cleanup` - boolean_true_false
         *
         *         Allows this resource to be cleaned up after toggle-disk + resync is finished
         *
         *     - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Linstor storage pool name for writecache
         *
         *     - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the writecache in % (0-100) or KiB otherwise
         *
         *     - `Writecache/Options/StartSector` - long
         *
         *         offset from the start of cache device in 512-byte sectors
         *
         *     - `Writecache/Options/HighWatermark` - long
         *
         *         start writeback when the number of used blocks reach this watermark
         *
         *     - `Writecache/Options/LowWatermark` - long
         *
         *         stop writeback when the number of used blocks drops below this watermark
         *
         *     - `Writecache/Options/WritebackJobs` - long
         *
         *         limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests
         *
         *     - `Writecache/Options/AutocommitBlocks` - long
         *
         *         when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited
         *
         *     - `Writecache/Options/AutocommitTime` - long
         *
         *         autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received
         *
         *     - `Writecache/Options/Fua` - enum
         *
         *         "On" results in "fua" as argument, whereas the value "Off" results in "nofua" argument
         *
         *         * On
         *         * Off
         *
         *     - `Writecache/Options/Additional` - string
         *
         *         Additional arguments passed through
         *
         *     - `Cache/OpMode` - enum
         *
         *         Operation mode
         *
         *         * writeback
         *         * writethrough
         *         * passthrough
         *
         *     - `Cache/MetaPool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Name of the storage pool used for the cache metadata. If not specified, this will default to the CachePool property
         *
         *     - `Cache/Metasize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the cache in % (0-100) or KiB otherwise.
         *
         *     - `Cache/CachePool` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]
         *
         *         Name of the storage pool used for the cache cache device
         *
         *     - `Cache/Cachesize` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]
         *
         *         Size of the cache in % (0-100) or KiB otherwise.
         *
         *     - `Cache/Blocksize` - long
         *
         *         Block size
         *
         *     - `Cache/Policy` - enum
         *
         *         Replacemant policy
         *
         *         * mq
         *         * smq
         *         * cleaner
         *
         *     - `StorDriver/LvcreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'lvcreate ... ' command
         *
         *     - `StorDriver/ZfscreateOptions` - regex[`.*`]
         *
         *         Additional parameters added to every 'zfs create ... ' command
         *
         *     - `StorDriver/Openflex/ApiHost` - regex[`.+`]
         *
         *         Openflex API host name
         *
         *     - `StorDriver/Openflex/ApiPort` - regex[`[0-9]+`]
         *
         *         Openflex API port
         *
         *     - `StorDriver/Openflex/UserName` - regex[`.+`]
         *
         *         Openflex user name
         *
         *     - `StorDriver/Openflex/UserPassword` - regex[`.+`]
         *
         *         Openflex password
         *
         *     - `StorDriver/Openflex/JobWaitDelay` - regex[`[0-9]+`]
         *
         *         Delay in milliseconds linstor waits between fetching the job status
         *
         *     - `StorDriver/Openflex/JobWaitMaxCount` - regex[`[0-9]+`]
         *
         *         Maximum retries with wait delay until openflex fails
         *
         *     - `Autoplacer/Weights/MaxFreeSpace` - regex[`^[0-9]+([.][0-9]+)?`]
         *
         *         Weight of 'MaxFreeSpace' autoplacer-strategy
         *
         *     - `Autoplacer/Weights/MinReservedSpace` - regex[`^[0-9]+([.][0-9]+)?`]
         *
         *         Weight of 'MinReservedSpace' autoplacer-strategy
         *
         *     - `Autoplacer/Weights/MinRscCount` - regex[`^[0-9]+([.][0-9]+)?`]
         *
         *         Weight of 'MinRscCount' autoplacer-strategy
         *
         *     - `Autoplacer/Weights/MaxThroughput` - regex[`^[0-9]+([.][0-9]+)?`]
         *
         *         Weight of 'MaxThroughput' autoplacer-strategy
         *
         *     - `Autoplacer/PreSelectScript` - string
         *
         *         Filename of the preselection script. File must be in /etc/linstor/selector/
         *
         *     - `Autoplacer/PreSelectScriptTimeout` - long
         *
         *         Timeout in ms Linstor waits for the script to run.
         *
         *     - `Autoplacer/MaxThroughput` - long
         *
         *         The maximum throughput the given storage pool is capable of.
         *
         *     - `DrbdProxy/AutoEnable` - boolean_true_false
         *     - `Site` - string
         *     - `UpdateCacheInterval` - long
         *
         *         Interval for space cache background updates in seconds
         *
         *     - `SnapshotShipping/TcpPortRange` - regex[`[0-9]+-[0-9]+`]
         *
         *         Range for allocation of snapshot shipping TCP ports
         *
         *     - `DrbdOptions/Disk/on-io-error` - enum
         *         * pass_on
         *         * call-local-io-error
         *         * detach
         *
         *     - `DrbdOptions/Disk/disk-barrier` - boolean
         *     - `DrbdOptions/Disk/disk-flushes` - boolean
         *     - `DrbdOptions/Disk/disk-drain` - boolean
         *     - `DrbdOptions/Disk/md-flushes` - boolean
         *     - `DrbdOptions/Disk/resync-after` - string
         *     - `DrbdOptions/Disk/al-extents` - range[`67-65534`]
         *     - `DrbdOptions/Disk/al-updates` - boolean
         *     - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean
         *     - `DrbdOptions/Disk/disable-write-same` - boolean
         *     - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`]
         *     - `DrbdOptions/Disk/read-balancing` - enum
         *         * prefer-local
         *         * prefer-remote
         *         * round-robin
         *         * least-pending
         *         * when-congested-remote
         *         * 32K-striping
         *         * 64K-striping
         *         * 128K-striping
         *         * 256K-striping
         *         * 512K-striping
         *         * 1M-striping
         *
         *     - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`]
         *     - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`]
         *     - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`]
         *     - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`]
         *     - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`]
         *     - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`]
         *     - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`]
         *     - `DrbdOptions/PeerDevice/bitmap` - boolean
         *     - `DrbdOptions/Resource/cpu-mask` - string
         *     - `DrbdOptions/Resource/on-no-data-accessible` - enum
         *         * io-error
         *         * suspend-io
         *
         *     - `DrbdOptions/Resource/auto-promote` - boolean
         *     - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`]
         *     - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`]
         *     - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`]
         *     - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`]
         *     - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`]
         *     - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`]
         *     - `DrbdOptions/Resource/quorum` - enum [`1-32`]
         *         * off
         *         * majority
         *         * all
         *
         *     - `DrbdOptions/Resource/on-no-quorum` - enum
         *         * io-error
         *         * suspend-io
         *
         *     - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]
         *         * off
         *         * majority
         *         * all
         *
         *     - `DrbdOptions/Net/transport` - string
         *     - `DrbdOptions/Net/protocol` - enum
         *         * A
         *         * B
         *         * C
         *
         *     - `DrbdOptions/Net/timeout` - range[`1-600`]
         *     - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`]
         *     - `DrbdOptions/Net/connect-int` - range[`1-120`]
         *     - `DrbdOptions/Net/ping-int` - range[`1-120`]
         *     - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Net/ko-count` - range[`0-200`]
         *     - `DrbdOptions/Net/allow-two-primaries` - boolean
         *     - `DrbdOptions/Net/cram-hmac-alg` - string
         *     - `DrbdOptions/Net/shared-secret` - string
         *     - `DrbdOptions/Net/after-sb-0pri` - enum
         *         * disconnect
         *         * discard-younger-primary
         *         * discard-older-primary
         *         * discard-zero-changes
         *         * discard-least-changes
         *         * discard-local
         *         * discard-remote
         *
         *     - `DrbdOptions/Net/after-sb-1pri` - enum
         *         * disconnect
         *         * consensus
         *         * discard-secondary
         *         * call-pri-lost-after-sb
         *         * violently-as0p
         *
         *     - `DrbdOptions/Net/after-sb-2pri` - enum
         *         * disconnect
         *         * call-pri-lost-after-sb
         *         * violently-as0p
         *
         *     - `DrbdOptions/Net/always-asbp` - boolean
         *     - `DrbdOptions/Net/rr-conflict` - enum
         *         * disconnect
         *         * call-pri-lost
         *         * violently
         *         * retry-connect
         *
         *     - `DrbdOptions/Net/ping-timeout` - range[`1-300`]
         *     - `DrbdOptions/Net/data-integrity-alg` - string
         *     - `DrbdOptions/Net/tcp-cork` - boolean
         *     - `DrbdOptions/Net/on-congestion` - enum
         *         * block
         *         * pull-ahead
         *         * disconnect
         *
         *     - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`]
         *     - `DrbdOptions/Net/congestion-extents` - range[`67-65534`]
         *     - `DrbdOptions/Net/csums-alg` - string
         *     - `DrbdOptions/Net/csums-after-crash-only` - boolean
         *     - `DrbdOptions/Net/verify-alg` - string
         *     - `DrbdOptions/Net/use-rle` - boolean
         *     - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`]
         *     - `DrbdOptions/Net/fencing` - enum
         *         * dont-care
         *         * resource-only
         *         * resource-and-stonith
         *
         *     - `DrbdOptions/Net/max-buffers` - range[`32-131072`]
         *     - `DrbdOptions/Net/allow-remote-read` - boolean
         *     - `DrbdOptions/Handlers/after-resync-target` - string
         *     - `DrbdOptions/Handlers/before-resync-target` - string
         *     - `DrbdOptions/Handlers/before-resync-source` - string
         *     - `DrbdOptions/Handlers/out-of-sync` - string
         *     - `DrbdOptions/Handlers/quorum-lost` - string
         *     - `DrbdOptions/Handlers/fence-peer` - string
         *     - `DrbdOptions/Handlers/unfence-peer` - string
         *     - `DrbdOptions/Handlers/initial-split-brain` - string
         *     - `DrbdOptions/Handlers/local-io-error` - string
         *     - `DrbdOptions/Handlers/pri-lost` - string
         *     - `DrbdOptions/Handlers/pri-lost-after-sb` - string
         *     - `DrbdOptions/Handlers/pri-on-incon-degr` - string
         *     - `DrbdOptions/Handlers/split-brain` - string
         *
         */
        post: operations["controllerPropertyModify"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/controller/properties/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Controller property key to delete */
                key: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Deletes a controller property
         * @description Delete a controller property
         */
        delete: operations["controllerPropertyDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/controller/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all controller properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for the LINSTOR controller.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A map where the key is the property name and the value is a
                 *     PropsInfo object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/controller/properties/info/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all properties of all entities
         * @description List all properties, including their names and descriptions, that can
         *     be set for any entity in the cluster. This includes the controller,
         *     resource definitions, resource groups, connections, volumes, etc.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A structure that maps entity types to a map of their properties.
                 *     The key is the entity type in uppercase. The value is a map
                 *     where the key is the property name and the value is a PropsInfo
                 *     object describing the property.
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: {
                                [key: string]: components["schemas"]["PropsInfo"];
                            };
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/controller/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * show controller config
         * @description Show Controller config
         *
         */
        get: operations["ControllerConfig"];
        /** modify controller config */
        put: operations["CtrlSetConfig"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/controller/backup/db": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * create a database backup
         * @description create a h2 database backup. Currently only H2(embedded) db is working.
         */
        post: operations["controllerBackupDB"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/controller/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * show controller version info
         * @description Show Controller version info
         *
         */
        get: operations["controllerVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/drbd-proxy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify drbd proxy option properties
         * @description Sets or modifies properties
         *
         *     Possible properties are:
         *     - `DrbdOptions/Proxy/memlimit` - range[`16777216-9223372036854775807`]
         *     - `DrbdOptions/Proxy/read-loops` - range[`0-2147483647`]
         *     - `DrbdOptions/Proxy/sndbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Proxy/rcvbuf-size` - range[`0-10485760`]
         *     - `DrbdOptions/Proxy/ping-timeout` - range[`1-300`]
         *     - `DrbdOptions/ProxyCompression/dict-size` - range[`4096-1610612736`]
         *     - `DrbdOptions/ProxyCompression/lc` - range[`0-4`]
         *     - `DrbdOptions/ProxyCompression/lp` - range[`0-4`]
         *     - `DrbdOptions/ProxyCompression/pb` - range[`0-4`]
         *     - `DrbdOptions/ProxyCompression/nice-len` - range[`0-273`]
         *     - `DrbdOptions/ProxyCompression/mf` - enum
         *         * hc4
         *         * hc3
         *         * bt2
         *         * bt3
         *         * bt4
         *
         *     - `DrbdOptions/ProxyCompression/mode` - enum
         *         * fast
         *         * normal
         *
         *     - `DrbdOptions/ProxyCompression/depth` - range[`0-1000`]
         *     - `DrbdOptions/ProxyCompression/level` - range[`1-9`]
         *     - `DrbdOptions/ProxyCompression/contexts` - range[`1-253`]
         *     - `DrbdOptions/ProxyCompression/fallback-to-zlib` - enum
         *         * off
         *         * on
         *
         *     - `DrbdOptions/ProxyCompression/numa-threshold` - range[`0-253`]
         *     - `DrbdOptions/ProxyCompression/level` - range[`1-9`]
         *     - `DrbdOptions/ProxyCompression/level` - range[`1-22`]
         *
         */
        put: operations["resourceDrbdProxyModify"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/drbd-proxy/properties/info": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        /**
         * List all drbd-proxy properties
         * @description List all properties, including their names and descriptions, that can
         *     be set for DRBD proxy on a given resource definition.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description resource to use */
                    resource: components["parameters"]["Resource"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A structure that maps the DBRD proxy configuration sections to their properties.
                 *     The key is the DRBD proxy configuration section The value is a map where the
                 *     key is the property name and the value is a PropsInfo object describing the
                 *     property.\
                 *     The following DRBD proxy configuration sections exist:
                 *     - DRBD_PROXY
                 *     - DRBD_PROXY_LZMA
                 *     - DRBD_PROXY_LZ4
                 *     - DRBD_PROXY_ZLIB
                 *     - DRBD_PROXY_ZSTD
                 *      */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["PropsInfo"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/drbd-proxy/enable/{node_a}/{node_b}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * enable a drbd proxy on a node connection
         * @description Enables a drbd proxy on a node connection
         */
        post: operations["resourceDrbdProxyEnable"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/resource-definitions/{resource}/drbd-proxy/disable/{node_a}/{node_b}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * disables a drbd proxy on a node connection
         * @description Disables a drbd proxy on a node connection
         */
        post: operations["resourceDrbdProxyDisable"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/encryption/passphrase": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** modifies the encryption passphrase */
        put: operations["encryptionPassphraseModify"];
        /** create a encryption passphrase */
        post: operations["encryptionPassphraseCreate"];
        delete?: never;
        options?: never;
        head?: never;
        /** enter the encryption passphrase */
        patch: operations["encryptionPassphraseEnter"];
        trace?: never;
    };
    "/v1/error-reports": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all error reports
         * @description List all error reports
         */
        get: operations["errorReportList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Deletes a range of error-reports
         * @description Deletes a range of error-reports
         */
        patch: operations["errorReportDelete"];
        trace?: never;
    };
    "/v1/stats/error-reports": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return stats of all error-reports.
         * @description Returns a error report stats object.
         *
         */
        get: operations["errorReportStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/error-reports/{reportid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * query the specified reportid
         * @description Query the specified reportid
         */
        get: operations["errorReportShow"];
        put?: never;
        post?: never;
        /**
         * Deletes a single error-report
         * @description Deletes a single error-report
         */
        delete: operations["errorReportDeleteSingle"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/key-value-store": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all key value stores
         * @description List all known key value store instances
         */
        get: operations["keyValueStoresList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/key-value-store/{instance}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the key value store */
                instance: string;
            };
            cookie?: never;
        };
        /**
         * list all key value stores
         * @description List all known key value store instances
         */
        get: operations["keyValueStoreList"];
        /**
         * modify a key value store
         * @description Modify a key value store
         */
        put: operations["keyValueStoreModify"];
        post?: never;
        /**
         * delete a key value store
         * @description Delete a key value store
         */
        delete: operations["keyValueStoreDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/query-max-volume-size": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        /**
         * query the maximum volume size
         * @description Query the maximum possible volume size storage pools
         */
        options: operations["queryMaxVolumeSize"];
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/view/resources": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * query all resources with their volumes
         * @description This REST-resource should be used if you want to get an overview of all resources with their volumes.
         */
        get: operations["viewResources"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/view/storage-pools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * query all storage pools
         * @description This REST-resource should be used if you want to get an overview of all storage pools.
         */
        get: operations["viewStoragePools"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/view/snapshots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * query all snapshots known to linstor
         * @description This REST-resource should be used if you want to get an overview of all snapshots.
         */
        get: operations["viewSnapshots"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/view/snapshot-shippings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** view current snapshot shippings */
        get: operations["viewSnapshotShippings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/view/schedules-by-resource": {
        parameters: {
            query?: {
                /** @description filter by rsc-name */
                rsc?: string;
                /** @description filter by remote-name */
                remote?: string;
                /** @description filter by schedule-name */
                schedule?: string;
                /** @description only list active schedules */
                "active-only"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list rscDfn-schedule-remote-triples
         * @description list all schedule-remote-rscDfn-triples
         */
        get: {
            parameters: {
                query?: {
                    /** @description filter by rsc-name */
                    rsc?: string;
                    /** @description filter by remote-name */
                    remote?: string;
                    /** @description filter by schedule-name */
                    schedule?: string;
                    /** @description only list active schedules */
                    "active-only"?: boolean;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description list of triples */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ScheduledRscsList"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/view/schedules-by-resource/{rscName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the rscDfn you want to see the schedule-details from */
                rscName: string;
            };
            cookie?: never;
        };
        /**
         * list schedule-details
         * @description list the details of all schedules set on a specific rscDfn
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description the rscDfn you want to see the schedule-details from */
                    rscName: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description list of schedule-details */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ScheduleDetailsList"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/view/backup/queue": {
        parameters: {
            query?: {
                /** @description filter by nodes */
                nodes?: string[];
                /** @description filter by snapshots */
                snapshots?: string[];
                /** @description filter by resources */
                resources?: string[];
                /** @description filter by remotes */
                remotes?: string[];
                /** @description group the result by snaps instead of by nodes */
                snap_to_node?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list queued snapshots
         * @description list which snaps are queued on which node
         */
        get: {
            parameters: {
                query?: {
                    /** @description filter by nodes */
                    nodes?: string[];
                    /** @description filter by snapshots */
                    snapshots?: string[];
                    /** @description filter by resources */
                    resources?: string[];
                    /** @description filter by remotes */
                    remotes?: string[];
                    /** @description group the result by snaps instead of by nodes */
                    snap_to_node?: boolean;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description map of nodes to snaps (or the other way around) */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["BackupQueues"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/stats/resources": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return stats of all resources.
         * @description Returns a resource stats object.
         *
         */
        get: operations["resourcesStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/stats/storage-pools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return stats of all storage pools.
         * @description Returns a storage pool stats object.
         *
         */
        get: operations["storagePoolsStats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/physical-storage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * show physical storage on nodes, to be used with LINSTOR
         * @description Gives a grouped list of physical storage that can be turned into a LINSTOR storage-pool
         */
        get: operations["viewPhysicaStorage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/physical-storage/{node}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * show physical storage on a single node
         * @description Gives a complete list of physical storage that can be turned into a LINSTOR storage-pool.
         *
         */
        get: operations["getPhysicalStorage"];
        put?: never;
        /**
         * creates an LVM, LVM-thin or ZFS pool, optional VDO under it
         * @description Creates a LVM/LVM-thin, ZFS pool on the given device and if supported VDO(optional) under it.
         *     logcal_size_kib parameter is only needed if LVM-thin or vdo is used.
         *     Also note VDO can only used with LVM-fat.
         *
         */
        post: operations["createDevicePool"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/sos-report": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** creates a SOS report in the log directory of the controller */
        get: operations["createSOSReport"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/sos-report/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** request sos report to download */
        get: operations["downloadSOSReport"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/{remote_name}/backups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all backups
         * @description list all backups in a single bucket
         */
        get: {
            parameters: {
                query?: {
                    /** @description Only show backups of this resource */
                    rsc_name?: string;
                    /** @description Only show backups with this snapshot name */
                    snap_name?: string;
                };
                header?: never;
                path: {
                    /** @description The remote to list the backups from */
                    remote_name: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description list of backups */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["BackupList"];
                    };
                };
            };
        };
        put?: never;
        /**
         * create a full or incremental backup
         * @description create and ship a full backup to the target system
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote to ship the backups to */
                    remote_name: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["BackupCreate"];
                };
            };
            responses: {
                /** @description backup created and shipping started */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        /**
         * delete backups
         * @description delete the specified backups
         */
        delete: {
            parameters: {
                query?: {
                    /** @description ID of the specific backup to be deleted */
                    id?: string;
                    /** @description ID prefix of possibly multiple backups to be deleted */
                    id_prefix?: string;
                    /** @description deletes the specified backup(s) and all backups depending on it */
                    cascading?: boolean;
                    /** @description deletes all backups that were made before the given timestamp */
                    timestamp?: string;
                    /** @description deletes all backups made from the specified resource */
                    resource_name?: string;
                    /** @description deletes all backups made from the specified node */
                    node_name?: string;
                    /** @description deletes all backups made from the current cluster */
                    all_local_cluster?: boolean;
                    /** @description deletes ALL backups */
                    all?: boolean;
                    /** @description deletes the backup associated with the s3key if it fits the naming-criteria */
                    s3key?: string;
                    /** @description deletes the s3key - regardless of whether it is a backup or not */
                    s3key_force?: string;
                    /** @description does not delete anything but returns an ApiCallRc with all entries that would be deleted */
                    dryrun?: boolean;
                    /** @description makes sure the snapshots the backups originated from are not deleted */
                    keep_snaps?: boolean;
                };
                header?: never;
                path: {
                    /** @description The remote to delete the backups from */
                    remote_name: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description backups deleted or error messages */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/{remote_name}/backups/restore": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * restore backups
         * @description restore the specified backups
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote to restore the backup from */
                    remote_name: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["BackupRestore"];
                };
            };
            responses: {
                /** @description backup restore started or error messages */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/{remote_name}/backups/abort": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * abort backups
         * @description abort all backups of the given resource
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote to abort the backups from */
                    remote_name: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["BackupAbort"];
                };
            };
            responses: {
                /** @description backups aborted or error messages */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/{remote_name}/backups/ship": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * ships a backup from one Linstor cluster to another
         * @description ships a backup from one Linstor cluster to another
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote to ship the backup to */
                    remote_name: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["BackupShip"];
                };
            };
            responses: {
                /** @description shippment has started or error messages */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/{remote_name}/backups/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * list info about a backup
         * @description get info about the storpools a backup uses and the size it needs
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote to get the info from */
                    remote_name: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["BackupInfoRequest"];
                };
            };
            responses: {
                /** @description successfully get the info */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["BackupInfo"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/{remote_name}/backups/schedule/{schedule_name}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * enable backup schedule
         * @description enable backups to be scheduled to a specific remote
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote to ship the backup to */
                    remote_name: string;
                    /** @description the schedule with which the backup should be shipped */
                    schedule_name: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["BackupSchedule"];
                };
            };
            responses: {
                /** @description backup schedule enabled sucessfully or error messages */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/{remote_name}/backups/schedule/{schedule_name}/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * disable backup schedule
         * @description disable backups to be scheduled to a specific remote
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The remote to ship the backup to */
                    remote_name: string;
                    /** @description the schedule with which the backup is being shipped */
                    schedule_name: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["BackupSchedule"];
                };
            };
            responses: {
                /** @description backup schedule disabled sucessfully or error messages */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/{remote_name}/backups/schedule/{schedule_name}/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * delete backup schedule
         * @description delete backups to be scheduled to a specific remote
         */
        delete: {
            parameters: {
                query?: {
                    /** @description the resource definition the schedule is assigned to */
                    rsc_dfn_name?: string;
                    /** @description the resource group the schedule is assigned to */
                    rsc_grp_name?: string;
                };
                header?: never;
                path: {
                    /** @description The remote to ship the backup to */
                    remote_name: string;
                    /** @description the schedule with which the backup is being shipped */
                    schedule_name: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description backup schedule deleted sucessfully or error messages */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/events/drbd/promotion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * drbd promotion event changes
         * @description Notifies clients about changes in may_promote of resources
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description drbd promotion event stream */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/event-stream": {
                            /** @enum {string} */
                            event?: "may-promote-change";
                            data?: components["schemas"]["EventMayPromoteChange"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/events/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * server sent event stream for nodes
         * @description Notifies clients about changes with nodes
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description linstor node events */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/event-stream": {
                            /** @enum {string} */
                            event?: "node-create";
                            data?: components["schemas"]["EventNode"];
                        } | {
                            /** @enum {string} */
                            event?: "node-delete";
                            data?: components["schemas"]["EventNode"];
                        } | {
                            /** @enum {string} */
                            event?: "node-evacuate";
                            data?: components["schemas"]["EventNode"];
                        } | {
                            /** @enum {string} */
                            event?: "node-evicted";
                            data?: components["schemas"]["EventNode"];
                        } | {
                            /** @enum {string} */
                            event?: "node-restored";
                            data?: components["schemas"]["EventNode"];
                        } | {
                            /** @enum {string} */
                            event?: "node-modified";
                            data?: components["schemas"]["EventNodeModified"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/vendor/seagate/exos/defaults": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lists default setting for all EXOS enclosures
         * @deprecated
         * @description Lists default setting for all EXOS enclosures
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description List of default settings */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ExosDefaults"][];
                    };
                };
            };
        };
        /**
         * modify default settings of EXOS configurations
         * @deprecated
         * @description Sets or modifies default username / password for EXOS enclosures
         *
         */
        put: operations["exosModifyDefault"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/vendor/seagate/exos/enclosures": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List of EXOS enclosures
         * @deprecated
         * @description Lists EXOS enclosures including controller IP and health status
         */
        get: {
            parameters: {
                query?: {
                    /** @description Force recaching before response */
                    nocache?: boolean;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description List of EXOS enclosures */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ExosEnclosureHealth"][];
                    };
                };
            };
        };
        put?: never;
        /**
         * creates a new enclosure
         * @deprecated
         * @description Creates a new enclosure unless it already exists
         */
        post: operations["exosCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/vendor/seagate/exos/enclosures/{enclosure}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * modifies an existing enclosure
         * @deprecated
         * @description Modifies an existing enclosure
         */
        put: operations["exosModify"];
        post?: never;
        /**
         * modifies an existing enclosure
         * @deprecated
         * @description Deletes an existing enclosure
         */
        delete: operations["exosDelete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/vendor/seagate/exos/{enclosure}/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns the last EXOS events
         * @deprecated
         * @description Lists the most current X events
         */
        get: operations["exosDescribe"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/vendor/seagate/exos/map": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lists all EXOS Ports connected to each Linstor Node
         * @deprecated
         * @description Lists the connection-mesh of EXOS Ports to Linstor Nodes
         */
        get: operations["exosMap"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all remotes
         * @description list of all known remotes on this cluster
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description list of remotes */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["RemoteList"][];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        /**
         * delete a remote
         * @description delete the given remote
         */
        delete: {
            parameters: {
                query: {
                    /** @description name of the remote */
                    remote_name: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description remote successfully deleted */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/s3/{remoteName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the remote */
                remoteName: string;
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a s3 remote
         * @description modify an existing s3 remote
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description name of the remote */
                    remoteName: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["S3Remote"];
                };
            };
            responses: {
                /** @description s3 remote modified */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/s3": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all s3 remotes
         * @description list of all known s3 remotes on this cluster
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description list of s3 remotes */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["S3Remote"][];
                    };
                };
            };
        };
        put?: never;
        /**
         * creates a new s3 remote
         * @description Creates a new s3 remote unless it already exists
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["S3Remote"];
                };
            };
            responses: {
                /** @description s3 remote successfully created */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/linstor": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all linstor remotes
         * @description list of all known linstor remotes on this cluster
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description list of linstor remotes */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["LinstorRemote"][];
                    };
                };
            };
        };
        put?: never;
        /**
         * creates a new linstor remote
         * @description Creates a new linstor remote unless it already exists
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["LinstorRemote"];
                };
            };
            responses: {
                /** @description linstor remote successfully created */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/linstor/{remoteName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the remote */
                remoteName: string;
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a linstor remote
         * @description modify an existing linstor remote
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description name of the remote */
                    remoteName: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["LinstorRemote"];
                };
            };
            responses: {
                /** @description linstor remote modified */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/ebs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all EBS remotes
         * @description list of all known EBS remotes on this cluster
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description list of EBS remotes */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["EbsRemote"][];
                    };
                };
            };
        };
        put?: never;
        /**
         * creates a new EBS remote
         * @description Creates a new EBS remote unless it already exists
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["EbsRemote"];
                };
            };
            responses: {
                /** @description EBS remote successfully created */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/remotes/ebs/{remoteName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the remote */
                remoteName: string;
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a EBS remote
         * @description modify an existing EBS remote
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description name of the remote */
                    remoteName: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["EbsRemote"];
                };
            };
            responses: {
                /** @description EBS remote modified */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/schedules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list all schedules
         * @description list of all known schedules on this cluster
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description list of schedules */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ScheduleList"];
                    };
                };
            };
        };
        put?: never;
        /**
         * creates a new schedule
         * @description Creates a new schedule unless it already exists
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["Schedule"];
                };
            };
            responses: {
                /** @description schedule successfully created */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/schedules/{scheduleName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the schedule */
                scheduleName: string;
            };
            cookie?: never;
        };
        get?: never;
        /**
         * modify a schedule
         * @description modify an existing schedule
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description name of the schedule */
                    scheduleName: string;
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["ScheduleModify"];
                };
            };
            responses: {
                /** @description schedule modified */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        post?: never;
        /**
         * delete a schedule
         * @description delete the given schedule
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description name of the schedule */
                    scheduleName: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description schedule successfully deleted */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/files": {
        parameters: {
            query?: {
                /** @description Include file content in response. If not given, defaults to false. */
                content?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list registered external files
         * @description Get a list of previously registered external files.
         *     File contents are not included, unless the "content" query parameter
         *     is explicitly set to true.
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description Include file content in response. If not given, defaults to false. */
                    content?: boolean;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description List of registered external files */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ExternalFile"][];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/files/{extFileName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /**
                 * @description Name of an external file. Must be an absolute path in URL-encoding
                 * @example %2Fetc%2Fsome.conf
                 */
                extFileName: components["parameters"]["ExternalFileName"];
            };
            cookie?: never;
        };
        /**
         * shows the requested external file including its content
         * @description Shows the requested external file including its content
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /**
                     * @description Name of an external file. Must be an absolute path in URL-encoding
                     * @example %2Fetc%2Fsome.conf
                     */
                    extFileName: components["parameters"]["ExternalFileName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description shows the requested external file including its content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ExternalFile"];
                    };
                };
            };
        };
        /**
         * register or modify a previously registered external file
         * @description Register or modify a previously registered external file
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /**
                     * @description Name of an external file. Must be an absolute path in URL-encoding
                     * @example %2Fetc%2Fsome.conf
                     */
                    extFileName: components["parameters"]["ExternalFileName"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["ExternalFile"];
                };
            };
            responses: {
                /** @description external file registered or modified */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        post?: never;
        /**
         * delete the given external file
         * @description Deletes the given external file. This effectively also deletes the file
         *     on all satellites
         *
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /**
                     * @description Name of an external file. Must be an absolute path in URL-encoding
                     * @example %2Fetc%2Fsome.conf
                     */
                    extFileName: components["parameters"]["ExternalFileName"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description File successfully deleted */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ApiCallRcList"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/files/{extFileName}/check/{node}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /**
                 * @description Name of an external file. Must be an absolute path in URL-encoding
                 * @example %2Fetc%2Fsome.conf
                 */
                extFileName: components["parameters"]["ExternalFileName"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        /**
         * checks whether an extFile can be written
         * @description checks whether the given extFile can be written on the given node
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /**
                     * @description Name of an external file. Must be an absolute path in URL-encoding
                     * @example %2Fetc%2Fsome.conf
                     */
                    extFileName: components["parameters"]["ExternalFileName"];
                    /** @description node to use */
                    node: components["parameters"]["Node"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description returns whether the file can be written */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ExtFileCheckResult"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/queries/resource-groups/query-all-size-info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Queries size information from all available resource groups
         * @description Unlike /v1/resource-groups/{resource_group}/query-size-info, this API
         *     returns the QSI result for all currently available resource groups
         *
         */
        post: operations["QryAllSizeInfo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description Common api reply structure */
        ApiCallRc: {
            /**
             * Format: int64
             * @description A masked error number
             */
            ret_code: number;
            /** @example Operation result. */
            message: string;
            /** @description Cause of the error */
            cause?: string;
            /** @description Details to the error message */
            details?: string;
            /** @description Possible correction options */
            correction?: string;
            /** @description List of error report ids related to this api call return code. */
            error_report_ids?: string[];
            /** @description Map of objection that have been involved by the operation. */
            obj_refs?: {
                [key: string]: string;
            };
            /** Format: date-time */
            created_at?: string;
        };
        ApiCallRcList: components["schemas"]["ApiCallRc"][];
        Node: {
            /** @example nodeA */
            name: string;
            /**
             * @example Satellite
             * @enum {string}
             */
            type: "Controller" | "Satellite" | "Combined" | "Auxiliary";
            flags?: string[];
            props?: components["schemas"]["Properties"];
            net_interfaces?: components["schemas"]["NetInterface"][];
            /**
             * @description Enum describing the current connection status.
             *
             * @example ONLINE
             * @enum {string}
             */
            connection_status?: "OFFLINE" | "CONNECTED" | "ONLINE" | "VERSION_MISMATCH" | "FULL_SYNC_FAILED" | "AUTHENTICATION_ERROR" | "UNKNOWN" | "HOSTNAME_MISMATCH" | "OTHER_CONTROLLER" | "AUTHENTICATED" | "NO_STLT_CONN";
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            storage_providers?: components["schemas"]["ProviderKind"][];
            resource_layers?: components["schemas"]["LayerType"][];
            unsupported_providers?: {
                [key: string]: string[];
            };
            unsupported_layers?: {
                [key: string]: string[];
            };
            /**
             * Format: int64
             * @description milliseconds since unix epoch in UTC
             */
            eviction_timestamp?: number;
        };
        NodeCreateEbs: {
            /** @example nodeA */
            name: string;
            /** @example EbsRemote */
            ebs_remote_name: string;
        };
        NodeModify: {
            node_type?: string;
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        NodeRestore: {
            delete_resources?: boolean;
            delete_snapshots?: boolean;
        };
        NetInterface: {
            /** @example default */
            name: string;
            /** @example 10.0.0.2 */
            address: string;
            /** @example 3366 */
            satellite_port?: number;
            /**
             * @example PLAIN
             * @enum {string}
             */
            satellite_encryption_type?: "PLAIN" | "SSL";
            /** @description Defines if this netinterface should be used for the satellite connection */
            is_active?: boolean;
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
        };
        /** @description A string to string property map. */
        Properties: {
            [key: string]: string;
        };
        PropertyWithDescription: {
            type: string;
            value: string;
            descr?: string;
        };
        EffectivePropertiesMapValue: components["schemas"]["PropertyWithDescription"] & {
            other?: components["schemas"]["PropertyWithDescription"][];
        };
        EffectivePropertiesMap: {
            [key: string]: components["schemas"]["EffectivePropertiesMapValue"];
        };
        /** @enum {string} */
        ProviderKind: "DISKLESS" | "LVM" | "LVM_THIN" | "ZFS" | "ZFS_THIN" | "FILE" | "FILE_THIN" | "SPDK" | "EBS_TARGET" | "EBS_INIT";
        /** @description Contains information about a storage pool.
         *
         *     If state is `Error` check the storage pool object path for detailed error description:
         *
         *       /v1/nodes/{nodename}/storage-pools/{poolname}
         *      */
        StoragePool: {
            /** @example DfltStorPool */
            storage_pool_name: string;
            node_name?: string;
            provider_kind: components["schemas"]["ProviderKind"];
            props?: components["schemas"]["Properties"];
            /** @description read only map of static storage pool traits */
            readonly static_traits?: {
                [key: string]: string;
            };
            /**
             * Format: int64
             * @description Kibi - read only
             * @example 882894848
             */
            free_capacity?: number;
            /**
             * Format: int64
             * @description Kibi - read only
             * @example 1056964608
             */
            total_capacity?: number;
            /**
             * @description read only
             * @example drbd1:myfastpool
             */
            free_space_mgr_name?: string;
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            /** @description Currently known report messages for this storage pool */
            readonly reports?: components["schemas"]["ApiCallRc"][];
            /** @description true if the storage pool supports snapshots. false otherwise */
            supports_snapshots?: boolean;
            /** @description Name of the shared space or null if none given */
            shared_space?: string;
            /**
             * @description true if a shared storage pool uses linstor-external locking, like cLVM
             * @default false
             */
            external_locking: boolean;
        };
        /** @enum {string} */
        LayerType: "DRBD" | "LUKS" | "STORAGE" | "NVME" | "WRITECACHE" | "CACHE" | "BCACHE";
        DrbdResourceDefinitionLayer: {
            resource_name_suffix?: string;
            /** Format: int32 */
            peer_slots?: number;
            /** Format: int32 */
            al_stripes?: number;
            /** Format: int64 */
            al_stripe_size_kib?: number;
            /**
             * Format: int32
             * @description used drbd port for this resource
             * @example 7000
             */
            port?: number;
            transport_type?: string;
            /**
             * @description drbd resource secret
             * @example 7sqCWjvGmwAiV5kzg3VF
             */
            secret?: string;
            down?: boolean;
        };
        ResourceDefinitionLayer: {
            type?: components["schemas"]["LayerType"];
            data?: components["schemas"]["DrbdResourceDefinitionLayer"];
        };
        ResourceDefinition: {
            /**
             * @default
             * @example rsc1
             */
            name: string;
            external_name?: components["schemas"]["ExternalName"];
            props?: components["schemas"]["Properties"];
            flags?: string[];
            layer_data?: components["schemas"]["ResourceDefinitionLayer"][];
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            /** @description name of the linked resource group, if there is a link */
            resource_group_name?: string;
            volume_definitions?: components["schemas"]["VolumeDefinition"][];
        };
        ResourceDefinitionCreate: {
            /**
             * Format: int32
             * @description drbd port for resources
             */
            drbd_port?: number;
            /**
             * @description drbd resource secret
             * @example 7sqCWjvGmwAiV5kzg3VF
             */
            drbd_secret?: string;
            /**
             * Format: int32
             * @description drbd peer slot number
             */
            drbd_peer_slots?: number;
            /** @example IP */
            drbd_transport_type?: string;
            resource_definition: components["schemas"]["ResourceDefinition"];
        };
        ResourceDefinitionModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
            /**
             * Format: int32
             * @description drbd port for resources
             */
            drbd_port?: number;
            /**
             * Format: int32
             * @description drbd peer slot number
             */
            drbd_peer_slots?: number;
            layer_stack?: components["schemas"]["LayerType"][];
            /** @description change resource group to the given group name */
            resource_group?: string;
        };
        DrbdVolumeDefinition: {
            resource_name_suffix?: string;
            /** Format: int32 */
            volume_number?: number;
            /** Format: int32 */
            minor_number?: number;
        };
        VolumeDefinitionLayer: {
            type: components["schemas"]["LayerType"];
            data?: components["schemas"]["DrbdVolumeDefinition"];
        };
        VolumeDefinition: {
            /** Format: int32 */
            volume_number?: number;
            /**
             * Format: int64
             * @description Size of the volume in Kibi.
             */
            size_kib: number;
            props?: components["schemas"]["Properties"];
            flags?: string[];
            layer_data?: components["schemas"]["VolumeDefinitionLayer"][];
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
        };
        VolumeDefinitionCreate: {
            volume_definition: components["schemas"]["VolumeDefinition"];
            /** Format: int32 */
            drbd_minor_number?: number;
            /** @description optional passphrase for encrypted volumes */
            passphrase?: string;
        };
        VolumeDefinitionModify: {
            /** Format: int64 */
            size_kib?: number;
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
            /** @description To add a flag just specify the flag name, to remove a flag prepend it with a '-'.
             *
             *     Flags:
             *       * GROSS_SIZE
             *      */
            flags?: string[];
        };
        VolumeDefinitionModifyPassphrase: {
            /** Format: password */
            new_passphrase: string;
        };
        DrbdResource: {
            drbd_resource_definition?: components["schemas"]["DrbdResourceDefinitionLayer"];
            /** Format: int32 */
            node_id?: number;
            /** Format: int32 */
            peer_slots?: number;
            /** Format: int32 */
            al_stripes?: number;
            /** Format: int64 */
            al_size?: number;
            flags?: string[];
            drbd_volumes?: components["schemas"]["DrbdVolume"][];
            connections?: {
                [key: string]: components["schemas"]["DrbdConnection"];
            };
            /** Format: int32 */
            promotion_score?: number;
            may_promote?: boolean;
        };
        StorageResource: {
            storage_volumes?: components["schemas"]["StorageVolume"][];
        };
        LUKSResource: {
            luks_volumes?: components["schemas"]["LUKSVolume"][];
        };
        NVMEResource: {
            nvme_volumes?: components["schemas"]["NVMEVolume"][];
        };
        WritecacheResource: {
            writecache_volumes?: components["schemas"]["WritecacheVolume"][];
        };
        CacheResource: {
            cache_volumes?: components["schemas"]["CacheVolume"][];
        };
        BCacheResource: {
            bcache_volumes?: components["schemas"]["BCacheVolume"][];
        };
        ResourceLayer: {
            children?: components["schemas"]["ResourceLayer"][];
            resource_name_suffix?: string;
            type?: components["schemas"]["LayerType"];
            drbd?: components["schemas"]["DrbdResource"];
            luks?: components["schemas"]["LUKSResource"];
            storage?: components["schemas"]["StorageResource"];
            nvme?: components["schemas"]["NVMEResource"];
            writecache?: components["schemas"]["WritecacheResource"];
            cache?: components["schemas"]["CacheResource"];
            bcache?: components["schemas"]["BCacheResource"];
        };
        ResourceState: {
            in_use?: boolean;
        };
        DrbdConnection: {
            connected?: boolean;
            /**
             * @description DRBD connection status
             * @example Connected
             * @enum {string}
             */
            message?: "StandAlone" | "Disconnecting" | "Unconnected" | "Timeout" | "BrokenPipe" | "NetworkFailure" | "ProtocolError" | "Connecting" | "TearDown" | "Connected" | "Unknown";
        };
        Resource: {
            /** @example rsc1 */
            name?: string;
            /** @example nodeA */
            node_name?: string;
            props?: components["schemas"]["Properties"];
            effective_props?: components["schemas"]["EffectivePropertiesMap"];
            flags?: string[];
            layer_object?: components["schemas"]["ResourceLayer"];
            state?: components["schemas"]["ResourceState"];
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            /**
             * Format: int64
             * @description milliseconds since unix epoch in UTC
             */
            create_timestamp?: number;
        };
        ResourceWithVolumes: components["schemas"]["Resource"] & {
            volumes?: components["schemas"]["Volume"][];
            /** @description shared space name of the data storage pool of the first volume of
             *     the resource or empty if data storage pool is not shared
             *      */
            shared_name?: string;
        };
        ResourceCreate: {
            resource?: components["schemas"]["Resource"];
            layer_list?: components["schemas"]["LayerType"][];
            /** Format: int32 */
            drbd_node_id?: number;
        };
        ResourceMakeAvailable: {
            layer_list?: components["schemas"]["LayerType"][];
            /**
             * @description if true resource will be created as diskful even if diskless would be possible
             * @default false
             */
            diskful: boolean;
        };
        ResourceModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        VolumeModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        DrbdVolume: {
            drbd_volume_definition?: components["schemas"]["DrbdVolumeDefinition"];
            /** @description drbd device path e.g. '/dev/drbd1000' */
            device_path?: string;
            /** @description block device used by drbd */
            backing_device?: string;
            meta_disk?: string;
            /** Format: int64 */
            allocated_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
            /** @description String describing current volume state */
            disk_state?: string;
            /** @description Storage pool name used for external meta data; null for internal */
            ext_meta_stor_pool?: string;
        };
        LUKSVolume: {
            /** Format: int32 */
            volume_number?: number;
            /** @description block device path */
            device_path?: string;
            /** @description block device used by luks */
            backing_device?: string;
            /** Format: int64 */
            allocated_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
            /** @description String describing current volume state */
            disk_state?: string;
            opened?: boolean;
        };
        StorageVolume: {
            /** Format: int32 */
            volume_number?: number;
            /** @description block device path */
            device_path?: string;
            /** Format: int64 */
            allocated_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
            /** @description String describing current volume state */
            disk_state?: string;
        };
        NVMEVolume: {
            /** Format: int32 */
            volume_number?: number;
            /** @description block device path */
            device_path?: string;
            /** @description block device used by nvme */
            backing_device?: string;
            /** Format: int64 */
            allocated_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
            /** @description String describing current volume state */
            disk_state?: string;
        };
        WritecacheVolume: {
            /** Format: int32 */
            volume_number?: number;
            /** @description block device path */
            device_path?: string;
            /** @description block device path used as cache device */
            device_path_cache?: string;
            /** Format: int64 */
            allocated_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
            /** @description String describing current volume state */
            disk_state?: string;
        };
        CacheVolume: {
            /** Format: int32 */
            volume_number?: number;
            /** @description block device path */
            device_path?: string;
            /** @description block device path used as cache device */
            device_path_cache?: string;
            /** @description block device path used as meta device */
            device_meta_cache?: string;
            /** Format: int64 */
            allocated_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
            /** @description String describing current volume state */
            disk_state?: string;
        };
        BCacheVolume: {
            /** Format: int32 */
            volume_number?: number;
            /** @description block device path */
            device_path?: string;
            /** @description block device path used as cache device */
            device_path_cache?: string;
            /** Format: int64 */
            allocated_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
            /** @description String describing current volume state */
            disk_state?: string;
        };
        VolumeLayer: {
            type?: components["schemas"]["LayerType"];
            data?: components["schemas"]["DrbdVolume"] | components["schemas"]["LUKSVolume"] | components["schemas"]["StorageVolume"] | components["schemas"]["NVMEVolume"] | components["schemas"]["WritecacheVolume"] | components["schemas"]["CacheVolume"] | components["schemas"]["BCacheVolume"];
        };
        Volume: {
            /** Format: int32 */
            volume_number?: number;
            storage_pool_name?: string;
            provider_kind?: components["schemas"]["ProviderKind"];
            device_path?: string;
            /** Format: int64 */
            allocated_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
            props?: components["schemas"]["Properties"];
            flags?: string[];
            state?: components["schemas"]["VolumeState"];
            layer_data_list?: components["schemas"]["VolumeLayer"][];
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            reports?: components["schemas"]["ApiCallRc"][];
        };
        VolumeState: {
            disk_state?: string;
        };
        ResourceGroup: {
            /**
             * @default
             * @example rscgrp1
             */
            name: string;
            /** @default  */
            description: string;
            props?: components["schemas"]["Properties"];
            select_filter?: components["schemas"]["AutoSelectFilter"];
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            /** Format: int32 */
            peer_slots?: number;
        };
        ResourceGroupModify: {
            description?: string;
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
            select_filter?: components["schemas"]["AutoSelectFilter"];
            /** Format: int32 */
            peer_slots?: number;
        };
        ResourceGroupSpawn: {
            /** @description name of the resulting resource-definition */
            resource_definition_name?: string;
            resource_definition_external_name?: components["schemas"]["ExternalName"];
            /** @description sizes (in kib) of the resulting volume-definitions */
            volume_sizes?: number[];
            select_filter?: components["schemas"]["AutoSelectFilter"];
            /**
             * @description If false, the length of the vlm_sizes has to match the number of volume-groups or an
             *     error is returned.
             *
             *     If true and there are more vlm_sizes than volume-groups, the additional volume-definitions
             *     will simply have no pre-set properties (i.e. "empty" volume-definitions)
             *     If true and there are less vlm_sizes than volume-groups, the additional volume-groups
             *     won't be used.
             *
             *     If the count of vlm_sizes matches the number of volume-groups, this "partial" parameter
             *     has no effect.
             *
             * @default false
             */
            partial: boolean;
            /**
             * @description If true, the spawn command will only create the resource-definition with the volume-definitions
             *     but will not perform an auto-place, even if it is configured.
             *
             * @default false
             */
            definitions_only: boolean;
            /** Format: int32 */
            peer_slots?: number;
            /** @description For volumes with encryption's, you can provide your own passphrases here. */
            volume_passphrases?: string[];
            resource_definition_props?: components["schemas"]["Properties"];
        };
        VolumeGroup: {
            /** Format: int32 */
            volume_number?: number;
            props?: components["schemas"]["Properties"];
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            flags?: string[];
        };
        VolumeGroupModify: {
            override_props?: components["schemas"]["Properties"];
            /** @description To add a flag just specify the flag name, to remove a flag prepend it with a '-'.
             *
             *     Flags:
             *       * GROSS_SIZE
             *      */
            flags?: string[];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        ResourceGroupAdjust: {
            select_filter?: components["schemas"]["AutoSelectFilter"];
        };
        AutoPlaceRequest: {
            /** @default false */
            diskless_on_remaining: boolean;
            select_filter: components["schemas"]["AutoSelectFilter"];
            /** @default null */
            layer_list: components["schemas"]["LayerType"][];
        };
        AutoSelectFilter: {
            /** Format: int32 */
            place_count?: number;
            /** Format: int32 */
            additional_place_count?: number;
            node_name_list?: string[];
            storage_pool?: string;
            /** @default null */
            storage_pool_list: string[];
            /** @default null */
            storage_pool_diskless_list: string[];
            /** @default null */
            not_place_with_rsc: string[];
            not_place_with_rsc_regex?: string;
            /** @default null */
            replicas_on_same: string[];
            /** @default null */
            replicas_on_different: string[];
            /** @default null */
            x_replicas_on_different_map: {
                [key: string]: number;
            };
            /** @default null */
            layer_stack: string[];
            /** @default null */
            provider_list: string[];
            diskless_on_remaining?: boolean;
            diskless_type?: string;
            /**
             * Format: double
             * @description Multiplier of thin storage pool's free space
             */
            overprovision?: number;
        };
        Candidate: {
            /** @example DfltStorPool */
            storage_pool?: string;
            /**
             * Format: int64
             * @description maximum size in KiB
             * @example 3194880
             */
            max_volume_size_kib?: number;
            node_names?: string[];
            all_thin?: boolean;
        };
        MaxVolumeSizes: {
            candidates?: components["schemas"]["Candidate"][];
            /** Format: double */
            default_max_oversubscription_ratio?: number;
        };
        QuerySizeInfoRequest: {
            select_filter?: components["schemas"]["AutoSelectFilter"];
            /**
             * Format: int32
             * @default -1
             */
            ignore_cache_older_than_sec: number;
        };
        QuerySizeInfoResponse: {
            space_info?: components["schemas"]["QuerySizeInfoResponseSpaceInfo"];
            reports?: components["schemas"]["ApiCallRc"][];
        };
        QueryAllSizeInfoRequest: {
            select_filter?: components["schemas"]["AutoSelectFilter"];
            /**
             * Format: int32
             * @default -1
             */
            ignore_cache_older_than_sec: number;
        };
        QueryAllSizeInfoResponse: {
            result?: {
                [key: string]: components["schemas"]["QuerySizeInfoResponse"];
            };
            reports?: components["schemas"]["ApiCallRc"][];
        };
        QuerySizeInfoResponseSpaceInfo: {
            /**
             * Format: int64
             * @description maximum size in KiB
             * @example 3194880
             */
            max_vlm_size_in_kib: number;
            /**
             * Format: int64
             * @description available size of the storage pools in KiB
             * @example 319488000
             */
            available_size_in_kib?: number;
            /**
             * Format: int64
             * @description capacity of the storage pools in KiB
             * @example 319488000
             */
            capacity_in_kib?: number;
            /** Format: double */
            default_max_oversubscription_ratio?: number;
            /** Format: double */
            max_oversubscription_ratio?: number;
            /** Format: double */
            max_free_capacity_oversubscription_ratio?: number;
            /** Format: double */
            max_total_capacity_oversubscription_ratio?: number;
            next_spawn_result?: components["schemas"]["QuerySizeInfoSpawnResult"][];
        };
        QuerySizeInfoSpawnResult: {
            node_name: string;
            stor_pool_name: string;
            /** Format: double */
            stor_pool_oversubscription_ratio?: number;
            /** Format: double */
            stor_pool_free_capacity_oversubscription_ratio?: number;
            /** Format: double */
            stor_pool_total_capacity_oversubscription_ratio?: number;
        };
        ControllerPropsModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        ControllerConfig: {
            config?: components["schemas"]["ControllerConfigConfig"];
            debug?: components["schemas"]["ControllerConfigDebug"];
            log?: components["schemas"]["ControllerConfigLog"];
            db?: components["schemas"]["ControllerConfigDb"];
            http?: components["schemas"]["ControllerConfigHttp"];
            https?: components["schemas"]["ControllerConfigHttps"];
            ldap?: components["schemas"]["ControllerConfigLdap"];
        };
        ControllerConfigConfig: {
            dir?: string;
        };
        ControllerConfigDebug: {
            console_enabled?: boolean;
        };
        ControllerConfigLog: {
            print_stack_trace?: boolean;
            directory?: string;
            level?: components["schemas"]["LogLevel"];
            level_global?: components["schemas"]["LogLevel"];
            level_linstor?: components["schemas"]["LogLevel"];
            level_linstor_global?: components["schemas"]["LogLevel"];
            rest_access_log_path?: string;
            /** @enum {string} */
            rest_access_mode?: "APPEND" | "ROTATE_HOURLY" | "ROTATE_DAILY" | "NO_LOG";
        };
        ControllerConfigDb: {
            connection_url?: string;
            ca_certificate?: string;
            client_certificate?: string;
            in_memory?: string;
            version_check_disabled?: boolean;
            etcd?: components["schemas"]["ControllerConfigDbEtcd"];
            k8s?: components["schemas"]["ControllerConfigDbK8s"];
        };
        ControllerConfigDbEtcd: {
            /** Format: int32 */
            operations_per_transaction?: number;
            prefix?: string;
        };
        ControllerConfigDbK8s: {
            /** Format: int32 */
            request_retries?: number;
            /** Format: int32 */
            max_rollback_entries?: number;
        };
        ControllerConfigHttp: {
            enabled?: boolean;
            listen_address?: string;
            /** Format: int32 */
            port?: number;
        };
        ControllerConfigHttps: {
            enabled?: boolean;
            listen_address?: string;
            /** Format: int32 */
            port?: number;
        };
        ControllerConfigLdap: {
            enabled?: boolean;
            public_access_allowed?: boolean;
            uri?: string;
            dn?: string;
            search_base?: string;
            search_filter?: string;
        };
        /** @enum {string} */
        LogLevel: "ERROR" | "WARN" | "INFO" | "DEBUG" | "TRACE";
        ControllerVersion: {
            version?: string;
            git_hash?: string;
            build_time?: string;
            rest_api_version?: string;
        };
        DatabaseBackupRequest: {
            backup_name?: string;
        };
        SatelliteConfig: {
            config?: components["schemas"]["ControllerConfigConfig"];
            debug?: components["schemas"]["ControllerConfigDebug"];
            log?: components["schemas"]["SatelliteConfigLog"];
            stlt_override_node_name?: string;
            remote_spdk?: boolean;
            ebs?: boolean;
            special_satellite?: boolean;
            drbd_keep_res_pattern?: string;
            net?: components["schemas"]["SatelliteConfigNet"];
        };
        SatelliteConfigLog: {
            print_stack_trace?: boolean;
            directory?: string;
            level?: components["schemas"]["LogLevel"];
            level_linstor?: components["schemas"]["LogLevel"];
        };
        SatelliteConfigNet: {
            bind_address?: string;
            /** Format: int32 */
            port?: number;
            com_type?: string;
        };
        /** @example {
         *       "info": "sets the c-plan-ahead parameter for a peer device",
         *       "prop_type": "range",
         *       "value": "(0 - 300)",
         *       "dflt": "20",
         *       "unit": "1/10 seconds"
         *     } */
        PropsInfo: {
            info?: string;
            prop_type?: string;
            value?: string;
            dflt?: string;
            unit?: string;
        };
        /** @example {
         *       "node_name": "Controller",
         *       "error_time": 1536827504594,
         *       "filename": "ErrorReport-5B9A15B7-00000-000000.log"
         *     } */
        ErrorReport: {
            node_name?: string;
            /** Format: int64 */
            error_time: number;
            /** @description Filename of the error report on the server.
             *
             *     Format is:
             *     ```ErrorReport-{instanceid}-{nodeid}-{sequencenumber}.log```
             *      */
            filename?: string;
            /** @description Contains the full text of the error report file. */
            text?: string;
            /** @description Which module this error occurred. */
            module?: string;
            /** @description Linstor version this error report was created. */
            version?: string;
            /** @description Peer client that was involved. */
            peer?: string;
            /** @description Exception that occurred */
            exception?: string;
            /** @description Exception message */
            exception_message?: string;
            /** @description Origin file of the exception */
            origin_file?: string;
            /** @description Origin method where the exception occurred */
            origin_method?: string;
            /**
             * Format: int32
             * @description Origin line number
             */
            origin_line?: number;
        };
        ErrorReportDelete: {
            /**
             * Format: int64
             * @description timestamp in millis start date to delete
             */
            since?: number;
            /**
             * Format: int64
             * @description timestamp in millis for the end date to delete
             */
            to?: number;
            /** @description on which nodes to delete error-reports, if empty/null all nodes */
            nodes?: string[];
            /** @description delete all error reports with the given exception */
            exception?: string;
            /** @description delete all error reports from the given version */
            version?: string;
            /** @description error report ids to delete */
            ids?: string[];
        };
        KeyValueStore: {
            /** @description name of the key value store */
            name?: string;
            props?: components["schemas"]["Properties"];
        };
        KeyValueStoreModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        NodeConnection: {
            /** @description source node of the connection */
            node_a?: string;
            /** @description target node of the connection */
            node_b?: string;
            props?: components["schemas"]["Properties"];
        };
        NodeConnectionModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        ResourceConnection: {
            /** @description source node of the connection */
            node_a?: string;
            /** @description target node of the connection */
            node_b?: string;
            props?: components["schemas"]["Properties"];
            flags?: string[];
            port?: number;
        };
        ResourceConnectionModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        CreateMultiSnapshotRequest: {
            snapshots?: components["schemas"]["Snapshot"][];
        };
        Snapshot: {
            name?: string;
            resource_name?: string;
            nodes?: string[];
            /** @deprecated */
            props?: components["schemas"]["Properties"];
            snapshot_definition_props?: components["schemas"]["Properties"];
            resource_definition_props?: components["schemas"]["Properties"];
            flags?: string[];
            volume_definitions?: components["schemas"]["SnapshotVolumeDefinition"][];
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            snapshots?: components["schemas"]["SnapshotNode"][];
        };
        SnapshotShippingStatus: {
            snapshot?: components["schemas"]["Snapshot"];
            from_node_name?: string;
            to_node_name?: string;
            /** @enum {string} */
            status?: "Running" | "Complete";
        };
        /** @description Objects holding one or multiple SnapshotVolumeNode objects for the given node */
        SnapshotNode: {
            /** @description Snapshot name this snapshots belongs to */
            snapshot_name?: string;
            /** @description Node name where this snapshot was taken */
            node_name?: string;
            /**
             * Format: int64
             * @description milliseconds since unix epoch in UTC
             */
            create_timestamp?: number;
            flags?: string[];
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            snapshot_props?: components["schemas"]["Properties"];
            resource_props?: components["schemas"]["Properties"];
            snapshot_volumes?: components["schemas"]["SnapshotVolumeNode"][];
        };
        /** @description Actual snapshot data from a node */
        SnapshotVolumeNode: {
            /**
             * @description unique object id
             * @example e8ef8d6b-17bc-42f0-9367-4aae40c78ecb
             */
            uuid?: string;
            /**
             * Format: int32
             * @description Volume number of the snapshot
             */
            vlm_nr?: number;
            /** @deprecated */
            props?: components["schemas"]["Properties"];
            snapshot_volume_props?: components["schemas"]["Properties"];
            volume_props?: components["schemas"]["Properties"];
            /** @description Optional state for the given snapshot */
            state?: string;
        };
        SnapshotVolumeDefinition: {
            /** Format: int32 */
            volume_number?: number;
            /**
             * Format: int64
             * @description Volume size in KiB
             */
            size_kib?: number;
            snapshot_volume_definition_props?: components["schemas"]["Properties"];
            volume_definition_props?: components["schemas"]["Properties"];
        };
        SnapshotRestore: {
            /**
             * @description Resource where to restore the snapshot
             * @example rsc2
             */
            to_resource: string;
            /** @description List of nodes where to place the restored snapshot */
            nodes?: string[];
            stor_pool_rename?: {
                [key: string]: string;
            };
        };
        SnapshotShipping: {
            /** @description Node where to ship the snapshot from */
            from_node: string;
            /** @description NetInterface of the source node */
            from_nic?: string;
            /** @description Node where to ship the snapshot */
            to_node: string;
            /** @description NetInterface of the destination node */
            to_nic?: string;
        };
        BackupList: {
            /** @description A list containing all entries found that are or could be from linstor */
            linstor?: {
                [key: string]: components["schemas"]["Backup"];
            };
            other?: components["schemas"]["BackupOther"];
        };
        Backup: {
            id: string;
            start_time?: string;
            /** Format: int64 */
            start_timestamp?: number;
            finished_time?: string;
            /** Format: int64 */
            finished_timestamp?: number;
            origin_rsc: string;
            origin_snap?: string;
            origin_node?: string;
            fail_messages?: string;
            vlms: components["schemas"]["BackupVolumes"][];
            success?: boolean;
            shipping?: boolean;
            restorable?: boolean;
            s3?: components["schemas"]["BackupS3"];
            based_on_id?: string;
        };
        BackupVolumes: {
            /** Format: int64 */
            vlm_nr: number;
            finished_time?: string;
            /** Format: int64 */
            finished_timestamp?: number;
            s3?: components["schemas"]["BackupVolumesS3"];
        };
        BackupVolumesS3: {
            key?: string;
        };
        BackupS3: {
            meta_name?: string;
        };
        /** @description A map containing all other entries found that have no relation to linstor */
        BackupOther: {
            files?: string[];
        };
        BackupRestore: {
            src_rsc_name?: string;
            src_snap_name?: string;
            last_backup?: string;
            stor_pool_map?: {
                [key: string]: string;
            };
            target_rsc_name: string;
            passphrase?: string;
            node_name: string;
            /** @default false */
            download_only: boolean;
            /** @default false */
            force_restore: boolean;
            dst_rsc_grp?: string;
            /**
             * @description If the destination resource-definition exists and has resources, the force_mv_rsc_grp must be used in order
             *     to change the resource-group of the destination resource-definition. This is a safety-option to prevent
             *     unexpected autoplace-actions for example performed by the BalanceResourceTask.
             *
             * @default false
             */
            force_mv_rsc_grp: boolean;
        };
        BackupCreate: {
            rsc_name: string;
            node_name?: string;
            snap_name?: string;
            incremental?: boolean;
        };
        BackupAbort: {
            rsc_name: string;
            restore?: boolean;
            create?: boolean;
        };
        BackupShip: {
            src_node_name?: string;
            src_rsc_name: string;
            dst_rsc_name: string;
            dst_node_name?: string;
            dst_net_if_name?: string;
            dst_stor_pool?: string;
            stor_pool_rename?: {
                [key: string]: string;
            };
            /** @default false */
            download_only: boolean;
            /** @default false */
            force_restore: boolean;
            /** @default true */
            allow_incremental: boolean;
            dst_rsc_grp?: string;
            /**
             * @description If the destination resource-definition exists and has resources, the force_mv_rsc_grp must be used in order
             *     to change the resource-group of the destination resource-definition. This is a safety-option to prevent
             *     unexpected autoplace-actions for example performed by the BalanceResourceTask.
             *
             * @default false
             */
            force_mv_rsc_grp: boolean;
        };
        BackupInfo: {
            rsc: string;
            full: string;
            snap?: string;
            latest: string;
            /** Format: int32 */
            count?: number;
            /** Format: int64 */
            dl_size_kib: number;
            /** Format: int64 */
            alloc_size_kib: number;
            storpools: components["schemas"]["BackupInfoStorPool"][];
        };
        BackupInfoRequest: {
            src_rsc_name?: string;
            src_snap_name?: string;
            last_backup?: string;
            stor_pool_map?: {
                [key: string]: string;
            };
            node_name?: string;
        };
        BackupInfoStorPool: {
            name: string;
            provider_kind?: components["schemas"]["ProviderKind"];
            target_name?: string;
            /** Format: int64 */
            remaining_space_kib?: number;
            vlms: components["schemas"]["BackupInfoVolume"][];
        };
        BackupInfoVolume: {
            name?: string;
            layer_type: components["schemas"]["LayerType"];
            /** Format: int64 */
            dl_size_kib?: number;
            /** Format: int64 */
            alloc_size_kib?: number;
            /** Format: int64 */
            usable_size_kib?: number;
        };
        BackupSchedule: {
            rsc_name?: string;
            grp_name?: string;
            node_name?: string;
            dst_stor_pool?: string;
            stor_pool_rename?: {
                [key: string]: string;
            };
            /** @default false */
            force_restore: boolean;
            dst_rsc_grp?: string;
            /**
             * @description If the destination resource-definition exists and has resources, the force_mv_rsc_grp must be used in order
             *     to change the resource-group of the destination resource-definition. This is a safety-option to prevent
             *     unexpected autoplace-actions for example performed by the BalanceResourceTask.
             *
             * @default false
             */
            force_mv_rsc_grp: boolean;
        };
        ScheduleDetailsList: {
            data?: components["schemas"]["ScheduleDetails"][];
        };
        ScheduleDetails: {
            remote_name: string;
            schedule_name: string;
            ctrl?: boolean;
            rsc_grp?: boolean;
            rsc_dfn?: boolean;
        };
        ScheduledRscsList: {
            data?: components["schemas"]["ScheduledRscs"][];
        };
        ScheduledRscs: {
            rsc_name: string;
            remote_name: string;
            schedule_name: string;
            /** @description The reason for why this rscDfn has no active schedules.
             *     If this is set, ignore all long and boolean parameters.
             *      */
            reason?: string;
            /**
             * Format: int64
             * @description The time at which the last scheduled shipping was shipped.
             *     If negative, no scheduled shipping has happened yet.
             *
             */
            last_snap_time?: number;
            /** @description Whether the last shipping was incremental or not.
             *     Ignore this value if last_snap_time is negative.
             *      */
            last_snap_inc?: boolean;
            /**
             * Format: int64
             * @description The time at which the next scheduled shipping will happen.
             *     If negative, the shipping is currently running.
             *
             */
            next_exec_time?: number;
            /** @description Whether the next scheduled shipping will be incremental or not.
             *     Ignore if next_exec_time is negative
             *      */
            next_exec_inc?: boolean;
            /**
             * Format: int64
             * @description The time at which the next scheduled full backup should happen.
             *     If negative, the time could not be computed
             *
             */
            next_planned_full?: number;
            /**
             * Format: int64
             * @description The time at which the next scheduled incremental backup should happen.
             *     If negative, either there is no cron for incremental backups or
             *     the time could not be computed
             *
             */
            next_planned_inc?: number;
        };
        BackupQueues: {
            /** @description All nodes with a list of queued snapshots. Will be empty
             *     if snap_queues is set
             *      */
            node_queues?: components["schemas"]["NodeQueue"][];
            /** @description All snapshots with a list of nodes they are queued on. Will be empty
             *     if node_queues is set
             *      */
            snap_queues?: components["schemas"]["SnapQueue"][];
        };
        NodeQueue: {
            node_name: string;
            /** @description The list of queued snapshots. Will be empty if this is an item of
             *     SnapQueue.queue
             *      */
            queue?: components["schemas"]["SnapQueue"][];
        };
        SnapQueue: {
            resource_name: string;
            snapshot_name: string;
            remote_name: string;
            incremental: boolean;
            based_on?: string;
            /** Format: int64 */
            start_timestamp: number;
            pref_node: string;
            /** @description The list of nodes this snapshot is queued on. Will be empty if this
             *     is an item of NodeQueue.queue
             *      */
            queue?: components["schemas"]["NodeQueue"][];
        };
        PassPhraseCreate: {
            new_passphrase?: string;
            old_passphrase?: string;
        };
        PassPhraseEnter: string;
        StoragePoolDefinition: {
            storage_pool_name?: string;
            props?: components["schemas"]["Properties"];
        };
        StoragePoolDefinitionModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            delete_namespaces?: string[];
        };
        DrbdProxyEnable: {
            /**
             * Format: int32
             * @description Proxy port to use (optional)
             */
            port?: number;
        };
        DrbdProxyModify: {
            override_props?: components["schemas"]["Properties"];
            delete_props?: string[];
            /**
             * @description Compression type used by the proxy.
             *
             * @enum {string}
             */
            compression_type?: "none" | "zlib" | "lzma" | "lz4";
            compression_props?: components["schemas"]["Properties"];
        };
        PhysicalStorageNode: {
            /** Format: int64 */
            size?: number;
            rotational?: boolean;
            device?: string;
            model?: string;
            serial?: string;
            wwn?: string;
        };
        PhysicalStorage: {
            /** Format: int64 */
            size?: number;
            rotational?: boolean;
            nodes?: {
                [key: string]: components["schemas"]["PhysicalStorageDevice"][];
            };
        };
        PhysicalStorageDevice: {
            device?: string;
            model?: string;
            serial?: string;
            wwn?: string;
        };
        /** @description This structure is used for create physical-storage */
        PhysicalStorageStoragePoolCreate: {
            /** @description Name of the linstor storage pool */
            name?: string;
            props?: components["schemas"]["Properties"];
            /** @description Name of the shared space */
            shared_space?: string;
            /**
             * @description true if a shared storage pool uses linstor-external locking, like cLVM
             * @default false
             */
            external_locking: boolean;
        };
        /** @description If `with_storage_pool` is set a linstor storage pool will also be created using this device pool */
        PhysicalStorageCreate: {
            provider_kind: components["schemas"]["ProviderKind"];
            device_paths: string[];
            /**
             * @description RAID level to use for pool.
             *
             * @default JBOD
             * @enum {string}
             */
            raid_level: "JBOD";
            pool_name?: string;
            /** @default false */
            vdo_enable: boolean;
            /**
             * Format: int64
             * @default 0
             */
            vdo_slab_size_kib: number;
            /**
             * Format: int64
             * @default 0
             */
            vdo_logical_size_kib: number;
            with_storage_pool?: components["schemas"]["PhysicalStorageStoragePoolCreate"];
            /**
             * @description initialize SED with a random password
             * @default false
             */
            sed: boolean;
        };
        /** @description may-promote-change */
        EventMayPromoteChange: {
            resource_name?: string;
            node_name?: string;
            may_promote?: boolean;
        };
        EventNode: {
            node?: components["schemas"]["Node"];
        };
        EventNodeModified: {
            old_node?: components["schemas"]["Node"];
            new_node?: components["schemas"]["Node"];
        };
        /**
         * @deprecated
         * @description Default settings for EXOS enclosures
         */
        ExosDefaults: {
            username?: string;
            username_env?: string;
            password?: string;
            password_env?: string;
        };
        /** @deprecated */
        ExosDefaultsModify: components["schemas"]["ExosDefaults"] & {
            /** @description A list of keys to unset. The keys have to exist in ExosDefaults
             *      */
            unset_keys?: string[];
        };
        /**
         * @deprecated
         * @description EXOS enclosure name, controller IPs and health status
         */
        ExosEnclosureHealth: {
            name?: string;
            ctrl_a_ip?: string;
            ctrl_b_ip?: string;
            health?: string;
            health_reason?: string;
        };
        /**
         * @deprecated
         * @description EXOS enclosure
         */
        ExosEnclosure: {
            name?: string;
            ctrl_a_ip?: string;
            ctrl_b_ip?: string;
            username?: string;
            username_env?: string;
            password?: string;
            password_env?: string;
        };
        /**
         * @deprecated
         * @description EXOS event
         */
        ExosEnclosureEvent: {
            severity?: string;
            event_id?: string;
            controller?: string;
            time_stamp?: string;
            /** Format: int64 */
            time_stamp_numeric?: number;
            message?: string;
            additional_information?: string;
            recommended_action?: string;
        };
        /** @deprecated */
        ExosConnectionMap: {
            node_name?: string;
            enclosure_name?: string;
            connections?: string[];
        };
        /** @description External file which can be configured to be deployed by Linstor */
        ExternalFile: {
            /**
             * @description The path where the external file should be deployed on the node
             * @example /etc/some.conf
             */
            path?: string;
            /**
             * @description The contents of the file, in base64 encoding
             * @example SGVsbG8sIFdvcmxkIQo=
             */
            content?: string;
        };
        ExtFileCheckResult: {
            allowed?: boolean;
        };
        /** @description ToggleDisk optional payload data */
        ToggleDiskDiskful: {
            layer_list?: components["schemas"]["LayerType"][];
        };
        /** @description External name can be used to have native resource names.
         *     If you need to store a non Linstor compatible resource name use this field
         *     and Linstor will generate a compatible name.
         *      */
        ExternalName: string;
        /** @description Clone request object */
        ResourceDefinitionCloneRequest: {
            name?: string;
            external_name?: components["schemas"]["ExternalName"];
            /** @description If true Zfs will not use send/recv to clone, but instead
             *     use a parent snapshot with clone, which cannot be deleted
             *      */
            use_zfs_clone?: boolean;
            layer_list?: components["schemas"]["LayerType"][];
            /** @description For volumes with encryption's, you can provide your own passphrases here. */
            volume_passphrases?: string[];
            /** @description Place clone into the given resource group and use storage pools of this group. */
            resource_group?: string;
        };
        /** @description Clone request started object */
        ResourceDefinitionCloneStarted: {
            /**
             * @description Path for clone status
             * @example /v1/resource-definitions/testres/clone/clonedresource
             */
            location: string;
            /** @description name of the source resource */
            source_name: string;
            /** @description name of the clone resource */
            clone_name: string;
            messages?: components["schemas"]["ApiCallRcList"];
        };
        /** @description Clone status object */
        ResourceDefinitionCloneStatus: {
            /**
             * @description CLONING -> indicates the resource is currently copying data
             *     FAILED -> error occured while cloning, resource not usable
             *     COMPLETE -> resource is ready to use
             *
             * @enum {string}
             */
            status: "COMPLETE" | "CLONING" | "FAILED";
        };
        /** @description Clone status object */
        ResourceDefinitionSyncStatus: {
            /** @default false */
            synced_on_all: boolean;
        };
        RemoteList: {
            s3_remotes?: components["schemas"]["S3Remote"][];
            linstor_remotes?: components["schemas"]["LinstorRemote"][];
            ebs_remotes?: components["schemas"]["EbsRemote"][];
        };
        S3Remote: {
            remote_name?: string;
            endpoint?: string;
            bucket?: string;
            region?: string;
            access_key?: string;
            secret_key?: string;
            /** @default false */
            use_path_style: boolean;
        };
        LinstorRemote: {
            remote_name?: string;
            url?: string;
            passphrase?: string;
            cluster_id?: string;
        };
        EbsRemote: {
            remote_name?: string;
            endpoint?: string;
            region?: string;
            availability_zone?: string;
            access_key?: string;
            secret_key?: string;
        };
        ScheduleList: {
            data?: components["schemas"]["Schedule"][];
        };
        Schedule: {
            schedule_name: string;
            full_cron: string;
            inc_cron?: string;
            /**
             * Format: int32
             * @description the number of snapshots that are basis for a full backup to keep locally
             */
            keep_local?: number;
            /**
             * Format: int32
             * @description the number of full backups to keep at the remote
             */
            keep_remote?: number;
            /**
             * @default SKIP
             * @enum {string}
             */
            on_failure: "SKIP" | "RETRY";
            /**
             * Format: int32
             * @description how many times a failed backup should be retried if on_failure == RETRY
             */
            max_retries?: number;
        };
        ScheduleModify: {
            full_cron?: string;
            inc_cron?: string;
            /**
             * Format: int32
             * @description the number of snapshots that are basis for a full backup to keep locally
             */
            keep_local?: number;
            /**
             * Format: int32
             * @description the number of full backups to keep at the remote
             */
            keep_remote?: number;
            /** @enum {string} */
            on_failure?: "SKIP" | "RETRY";
            /**
             * Format: int32
             * @description how many times a failed backup should be retried if on_failure == RETRY
             */
            max_retries?: number;
        };
        NodeStats: {
            /** Format: int64 */
            count: number;
        };
        StoragePoolStats: {
            /** Format: int64 */
            count: number;
        };
        ResourceGroupStats: {
            /** Format: int64 */
            count: number;
        };
        ResourceDefinitionStats: {
            /** Format: int64 */
            count: number;
        };
        ResourceStats: {
            /** Format: int64 */
            count: number;
        };
        ErrorReportStats: {
            /** Format: int64 */
            count: number;
        };
    };
    responses: {
        /** @description invalid input, or request failed */
        InvalidInput: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiCallRcList"];
            };
        };
        /** @description object not found */
        ObjectNotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiCallRcList"];
            };
        };
        /** @description operation failed */
        OperationFailed: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ApiCallRc"];
            };
        };
    };
    parameters: {
        /** @description resource to use */
        Resource: string;
        /** @description resource clone name */
        ResourceClone: string;
        /** @description resource group to use */
        ResourceGroupName: string;
        /** @description node to use */
        Node: string;
        /** @description Filter only for the specified nodes, if not specified, no filtering. */
        Nodes: string[];
        /** @description Filter only for the specified resources, if not specified, no filtering. */
        Resources: string[];
        /** @description netinterface name to use */
        NetInterface: string;
        /** @description Storage pool to use */
        StoragePool: string;
        /** @description number of records to skip for pagination */
        Offset: number;
        /** @description maximum number of records to return */
        Limit: number;
        /** @description query data from cache if available */
        Cached: boolean;
        /** @description filter by given properties, full property path */
        Props: string[];
        /** @description source node of the connection */
        NodeA: string;
        /** @description target node of the connection */
        NodeB: string;
        /** @description Volume number of the definition */
        VolumeNumber: number;
        /** @description Unix epoch milliseconds */
        Since: number;
        /**
         * @description Name of an external file. Must be an absolute path in URL-encoding
         * @example %2Fetc%2Fsome.conf
         */
        ExternalFileName: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    createMultiSnapshot: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "name": "snap1"
                 *     } */
                "application/json": components["schemas"]["CreateMultiSnapshotRequest"];
            };
        };
        responses: {
            /** @description Snapshot created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    storagePoolDfnList: {
        parameters: {
            query?: {
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of all storage pool definitions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoragePoolDefinition"][];
                };
            };
        };
    };
    storagePoolDfnAdd: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Storage pool definition to add */
        requestBody?: {
            content: {
                /** @example {
                 *       "storage_pool_name": "ssd_pool"
                 *     } */
                "application/json": components["schemas"]["StoragePoolDefinition"];
            };
        };
        responses: {
            /** @description storage pool definition created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    storagePoolDfnGet: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Specified storage pool definition */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoragePoolDefinition"];
                };
            };
        };
    };
    storPoolDfnModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["StoragePoolDefinitionModify"];
            };
        };
        responses: {
            /** @description storage pool definition modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    storagePoolDefinitionDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description storage pool definition deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    nodeList: {
        parameters: {
            query?: {
                /** @description Filter only for the specified nodes, if not specified, no filtering. */
                nodes?: components["parameters"]["Nodes"];
                /** @description filter by given properties, full property path */
                props?: components["parameters"]["Props"];
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of all node objects */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"][];
                };
            };
            400: components["responses"]["InvalidInput"];
        };
    };
    nodeAdd: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Node to add to Linstor */
        requestBody?: {
            content: {
                /** @example {
                 *       "name": "nodeA",
                 *       "type": "SATELLITE",
                 *       "net_interfaces": [
                 *         {
                 *           "name": "default",
                 *           "address": "10.0.0.2",
                 *           "satellite_port": 3366,
                 *           "satellite_encryption_type": "Plain",
                 *           "is_active": true
                 *         }
                 *       ]
                 *     } */
                "application/json": components["schemas"]["Node"];
            };
        };
        responses: {
            /** @description node created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    nodeStats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object stats */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeStats"];
                };
            };
            400: components["responses"]["InvalidInput"];
        };
    };
    nodeModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["NodeModify"];
            };
        };
        responses: {
            /** @description node modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    nodeDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description node deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    nodeLost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description node deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    nodeReconnect: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description node put into reconnect cycle */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    netinterfaceList: {
        parameters: {
            query?: {
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of net-interfaces */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NetInterface"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    netinterfaceCreate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["NetInterface"];
            };
        };
        responses: {
            /** @description netinterface created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    netinterfaceModified: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description netinterface name to use */
                netinterface: components["parameters"]["NetInterface"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["NetInterface"];
            };
        };
        responses: {
            /** @description netinterface modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    netinterfaceDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description netinterface name to use */
                netinterface: components["parameters"]["NetInterface"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description netinterface deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    nodeStoragePoolList: {
        parameters: {
            query?: {
                /** @description Filter only for the specified nodes, if not specified, no filtering. */
                nodes?: components["parameters"]["Nodes"];
                /** @description Filter only for the specified storage pools, if not specified no filtering. */
                storage_pools?: string[];
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
                /** @description query data from cache if available */
                cached?: components["parameters"]["Cached"];
            };
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array list of all storage pools */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoragePool"][];
                };
            };
        };
    };
    nodeStoragePoolCreate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "storage_pool_name": "DfltStorPool",
                 *       "provider_kind": "LVM_THIN",
                 *       "props": {
                 *         "StorDriver/LvmVg": "mylvmpool",
                 *         "StorDriver/ThinPool": "thin"
                 *       }
                 *     } */
                "application/json": components["schemas"]["StoragePool"];
            };
        };
        responses: {
            /** @description storage pool created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    nodeStoragePoolModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["StoragePoolDefinitionModify"];
            };
        };
        responses: {
            /** @description storage pool modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    nodeStoragePoolDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description storage pool deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    SatelliteConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Satellite config */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SatelliteConfig"];
                };
            };
            /** @description Access denied */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
            /** @description Node offline */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    StltSetConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SatelliteConfig"];
            };
        };
        responses: {
            /** @description Response on whether the operation was successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            /** @description Access denied */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    nodeEvacuate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resources started to evacaute */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    nodeAddEbs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Node to add to Linstor */
        requestBody?: {
            content: {
                /** @example {
                 *       "name": "nodeA",
                 *       "ebs_remote_name": "EbsRemote"
                 *     } */
                "application/json": components["schemas"]["NodeCreateEbs"];
            };
        };
        responses: {
            /** @description node created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    nodeConnectionsList: {
        parameters: {
            query?: {
                /** @description Filter only for node-connections from or to the given node */
                node_a?: string;
                /** @description Filter only for node-connections from or to the given node */
                node_b?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description list of node connections */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeConnection"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    nodeConnectionModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["NodeConnectionModify"];
            };
        };
        responses: {
            /** @description node connection modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            404: components["responses"]["ObjectNotFound"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceDefinitionList: {
        parameters: {
            query?: {
                /** @description Filter only for the specified resource definitions, if not specified no filtering. */
                resource_definitions?: string[];
                /** @description filter by given properties, full property path */
                props?: components["parameters"]["Props"];
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of all resource-definitions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceDefinition"][];
                };
            };
        };
    };
    resourceDefinitionCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "resource_definition": {
                 *         "name": "rsc1"
                 *       }
                 *     } */
                "application/json": components["schemas"]["ResourceDefinitionCreate"];
            };
        };
        responses: {
            /** @description resource-definition created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceDefinitionStats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object stats */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceDefinitionStats"];
                };
            };
            400: components["responses"]["InvalidInput"];
        };
    };
    resourceDefinitionModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["ResourceDefinitionModify"];
            };
        };
        responses: {
            /** @description resource-definition modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    resourceDefinitionDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resource-definition deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    resourceDefinitionClone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ResourceDefinitionCloneRequest"];
            };
        };
        responses: {
            /** @description resource defintion clone process started */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceDefinitionCloneStarted"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceDefinitionCloneStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description resource clone name */
                resourceClone: components["parameters"]["ResourceClone"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resource defintion clone status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceDefinitionCloneStatus"];
                };
            };
            404: components["responses"]["ObjectNotFound"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceDefinitionSyncStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resource defintion sync status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceDefinitionSyncStatus"];
                };
            };
            404: components["responses"]["ObjectNotFound"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceDeploy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /**
                 * @description Name of an external file. Must be an absolute path in URL-encoding
                 * @example %2Fetc%2Fsome.conf
                 */
                extFileName: components["parameters"]["ExternalFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description deployment of the external file enabled */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceUndeploy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /**
                 * @description Name of an external file. Must be an absolute path in URL-encoding
                 * @example %2Fetc%2Fsome.conf
                 */
                extFileName: components["parameters"]["ExternalFileName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description deployment of external file disabled */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    volumeDefinitionList: {
        parameters: {
            query?: {
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of all volume-definitions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VolumeDefinition"][];
                };
            };
        };
    };
    volumeDefinitionCreate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "volume_definition": {
                 *         "size_kib": 262144
                 *       }
                 *     } */
                "application/json": components["schemas"]["VolumeDefinitionCreate"];
            };
        };
        responses: {
            /** @description volume-definition created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    volumeDefinitionModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["VolumeDefinitionModify"];
            };
        };
        responses: {
            /** @description volume-definition modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    volumeDefinitionDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description volume-definition deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    volumeDefinitionModifyPassphrase: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VolumeDefinitionModifyPassphrase"];
            };
        };
        responses: {
            /** @description volume-definition passphrase modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    resourceList: {
        parameters: {
            query?: {
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of all resources for the resource-definition */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Resource"][];
                };
            };
        };
    };
    resourceCreate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example [
                 *       {
                 *         "resource": {
                 *           "name": "rsc1",
                 *           "node_name": "alpha"
                 *         }
                 *       }
                 *     ] */
                "application/json": components["schemas"]["ResourceCreate"][];
            };
        };
        responses: {
            /** @description resource created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["ResourceModify"];
            };
        };
        responses: {
            /** @description resource modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    resourceCreateOnNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {} */
                "application/json": components["schemas"]["ResourceCreate"];
            };
        };
        responses: {
            /** @description resource created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceDelete: {
        parameters: {
            query?: {
                /** @description Ensures that the tiebreaker resource is kept, possibly not deleting the given resource */
                keep_tiebreaker?: boolean;
            };
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resource deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    resourceMakeAvailableOnNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ResourceMakeAvailable"];
            };
        };
        responses: {
            /** @description resource is either created or ensured to be available */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    ActivateRsc: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Resource is now active */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    DeactivateRsc: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Resource is now inctive */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceVolumeList: {
        parameters: {
            query?: {
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of all volume for the resource */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Volume"][];
                };
            };
        };
    };
    volumeModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["VolumeModify"];
            };
        };
        responses: {
            /** @description volume modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    resourceToggleDiskless: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resource toggled to diskless */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceToggleDisklessDisklesspool: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description diskless pool to use. */
                disklesspool: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resource toggled to diskless resource */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceToggleDiskful: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "toggle_disk": {
                 *         "layer_list": [
                 *           "drbd",
                 *           "luks",
                 *           "storage"
                 *         ]
                 *       }
                 *     } */
                "application/json": components["schemas"]["ToggleDiskDiskful"];
            };
        };
        responses: {
            /** @description resource toggled to diskful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceToggleDiskfulStoragepool: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "toggle_disk": {
                 *         "layer_list": [
                 *           "drbd",
                 *           "luks",
                 *           "storage"
                 *         ]
                 *       }
                 *     } */
                "application/json": components["schemas"]["ToggleDiskDiskful"];
            };
        };
        responses: {
            /** @description resource toggled to diskful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceMigrateDisk: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description node that should be deleted after the successful migrate */
                fromnode: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "toggle_disk": {
                 *         "layer_list": [
                 *           "drbd",
                 *           "luks",
                 *           "storage"
                 *         ]
                 *       }
                 *     } */
                "application/json": components["schemas"]["ToggleDiskDiskful"];
            };
        };
        responses: {
            /** @description resource migrated to another node */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceMigrateDiskStoragepool: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description node to use */
                node: components["parameters"]["Node"];
                /** @description node that should be deleted after the successful migrate */
                fromnode: string;
                /** @description Storage pool to use */
                storagepool: components["parameters"]["StoragePool"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resource migrated to another node */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceAutoplace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "select_filter": {
                 *         "place_count": 2
                 *       }
                 *     } */
                "application/json": components["schemas"]["AutoPlaceRequest"];
            };
        };
        responses: {
            /** @description resource created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceConnectionsList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description list of resource connections */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceConnection"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceConnectionList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description list of resource connections */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceConnection"][];
                };
            };
            404: components["responses"]["ObjectNotFound"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceConnectionModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ResourceConnectionModify"];
            };
        };
        responses: {
            /** @description resource connection modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            404: components["responses"]["ObjectNotFound"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceSnapshotsList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshots for the resource */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Snapshot"][];
                };
            };
        };
    };
    resourceSnapshotCreate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "name": "snap1"
                 *     } */
                "application/json": components["schemas"]["Snapshot"];
            };
        };
        responses: {
            /** @description Snapshot created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceSnapshotList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Snapshot name to use */
                snapshot: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshot for the resource */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Snapshot"];
                };
            };
        };
    };
    resourceSnapshotDelete: {
        parameters: {
            query?: {
                /** @description Only delete snapshots of the given nodes. */
                nodes?: string[];
            };
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Snapshot name to use */
                snapshot: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshot deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceSnapshotRestore: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Snapshot name to use */
                snapshot: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SnapshotRestore"];
            };
        };
        responses: {
            /** @description Snapshot restored */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceSnapshotsRestoreVolumeDefinition: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Snapshot name to use */
                snapshot: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SnapshotRestore"];
            };
        };
        responses: {
            /** @description Snapshot restored */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceSnapshotRollback: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description Snapshot name to use */
                snapshot: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Snapshot rollbacked */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    snapshotShipping: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["SnapshotShipping"];
            };
        };
        responses: {
            /** @description Snapshot shipping in progress */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceGroupList: {
        parameters: {
            query?: {
                /** @description Filter only for the specified resource groups, if not specified no filtering. */
                resource_groups?: string[];
                /** @description filter by given properties, full property path */
                props?: components["parameters"]["Props"];
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of all resource-groups */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceGroup"][];
                };
            };
        };
    };
    resourceGroupCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "name": "rscgrp1"
                 *     } */
                "application/json": components["schemas"]["ResourceGroup"];
            };
        };
        responses: {
            /** @description resource-group created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceGroupStats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object stats */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceGroupStats"];
                };
            };
            400: components["responses"]["InvalidInput"];
        };
    };
    resourceGroupModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["ResourceGroupModify"];
            };
        };
        responses: {
            /** @description resource-group modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    resourceGroupDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resource-group deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    resourceGroupSpawn: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "resource_definition_name": "res1",
                 *       "volume_sizes": [
                 *         1048576,
                 *         20971520
                 *       ]
                 *     } */
                "application/json": components["schemas"]["ResourceGroupSpawn"];
            };
        };
        responses: {
            /** @description resource-definition created and auto-deployed if configured accordingly */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    volumeGroupList: {
        parameters: {
            query?: {
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of all volume-groups */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VolumeGroup"][];
                };
            };
        };
    };
    volumeGroupCreate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VolumeGroup"];
            };
        };
        responses: {
            /** @description volume-group created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    volumeGroupModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "1"
                 *       },
                 *       "delete_props": [
                 *         "Aux/deleteprop"
                 *       ]
                 *     } */
                "application/json": components["schemas"]["VolumeGroupModify"];
            };
        };
        responses: {
            /** @description volume-group modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    volumeGroupDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
                /** @description Volume number of the definition */
                volume_number: components["parameters"]["VolumeNumber"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description volume-group deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    queryMaxVolumeSizeFromRscGrp: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description list of usable storage pools */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MaxVolumeSizes"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    querySizeInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["QuerySizeInfoRequest"];
            };
        };
        responses: {
            /** @description collection of size info and list of usable storage pools */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QuerySizeInfoResponse"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceGroupAdjust: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource group to use */
                resource_group: components["parameters"]["ResourceGroupName"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ResourceGroupAdjust"];
            };
        };
        responses: {
            /** @description resource-definitions adjusted as configured. Might have created new resources. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceGroupAdjustAll: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ResourceGroupAdjust"];
            };
        };
        responses: {
            /** @description resource-definitions adjusted as configured. Might have created new resources. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    controllerPropertyList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A string to string map with all properties */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Properties"];
                };
            };
        };
    };
    controllerPropertyModify: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "Aux/testprop": "myprop"
                 *       }
                 *     } */
                "application/json": components["schemas"]["ControllerPropsModify"];
            };
        };
        responses: {
            /** @description Controller property created/modifed. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    controllerPropertyDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Controller property key to delete */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description property deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    ControllerConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Controller config */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ControllerConfig"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    CtrlSetConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ControllerConfig"];
            };
        };
        responses: {
            /** @description Response on whether the operation was successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            /** @description Access denied */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    controllerBackupDB: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DatabaseBackupRequest"];
            };
        };
        responses: {
            /** @description database backup created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    controllerVersion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Controller version info object */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ControllerVersion"];
                };
            };
        };
    };
    resourceDrbdProxyModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "override_props": {
                 *         "compression_type": "lz4"
                 *       }
                 *     } */
                "application/json": components["schemas"]["DrbdProxyModify"];
            };
        };
        responses: {
            /** @description drbd proxy properties modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceDrbdProxyEnable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DrbdProxyEnable"];
            };
        };
        responses: {
            /** @description drbd proxy configuration enabled */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    resourceDrbdProxyDisable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description resource to use */
                resource: components["parameters"]["Resource"];
                /** @description source node of the connection */
                node_a: components["parameters"]["NodeA"];
                /** @description target node of the connection */
                node_b: components["parameters"]["NodeB"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description drbd proxy configuration disabled */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    encryptionPassphraseModify: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["PassPhraseCreate"];
            };
        };
        responses: {
            /** @description encryption passphrase modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    encryptionPassphraseCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["PassPhraseCreate"];
            };
        };
        responses: {
            /** @description encryption passphrase created */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    encryptionPassphraseEnter: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["PassPhraseEnter"];
            };
        };
        responses: {
            /** @description encryption passphrase accepted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    errorReportList: {
        parameters: {
            query?: {
                /** @description Only show error reports of this node */
                node?: string;
                /** @description Unix epoch milliseconds */
                since?: components["parameters"]["Since"];
                /** @description Unix timestamp to the ending interval */
                to?: number;
                /** @description Include error report text in response. */
                withContent?: boolean;
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description list of error reports */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorReport"][];
                };
            };
            /** @description Query parameter invalid. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    errorReportDelete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ErrorReportDelete"];
            };
        };
        responses: {
            /** @description error-reports deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    errorReportStats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object stats */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorReportStats"];
                };
            };
            400: components["responses"]["InvalidInput"];
        };
    };
    errorReportShow: {
        parameters: {
            query?: {
                /** @description Only show error reports of this node */
                node?: string;
                /** @description Unix epoch milliseconds */
                since?: components["parameters"]["Since"];
                /** @description Unix timestamp to the ending interval */
                to?: number;
                /** @description Include error report text in response. */
                withContent?: boolean;
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path: {
                /** @description Error id to select */
                reportid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description list of error reports */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorReport"][];
                };
            };
            /** @description Query parameter invalid. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    errorReportDeleteSingle: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Error id to select */
                reportid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description error-report deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    keyValueStoresList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description list of key value stores */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KeyValueStore"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    keyValueStoreList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the key value store */
                instance: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description list of key value stores */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KeyValueStore"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    keyValueStoreModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the key value store */
                instance: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["KeyValueStoreModify"];
            };
        };
        responses: {
            /** @description key value store modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            400: components["responses"]["InvalidInput"];
            500: components["responses"]["OperationFailed"];
        };
    };
    keyValueStoreDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the key value store */
                instance: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description key value store deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    queryMaxVolumeSize: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AutoSelectFilter"];
            };
        };
        responses: {
            /** @description list of usable storage pools */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MaxVolumeSizes"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    viewResources: {
        parameters: {
            query?: {
                /** @description Filter only for the specified nodes, if not specified, no filtering. */
                nodes?: components["parameters"]["Nodes"];
                /** @description Filter only for the specified resources, if not specified, no filtering. */
                resources?: components["parameters"]["Resources"];
                /** @description Filter only for the specified storage pools, if not specified no filtering. */
                storage_pools?: string[];
                /** @description filter by given properties, full property path */
                props?: components["parameters"]["Props"];
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description resources list with volume data */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceWithVolumes"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    viewStoragePools: {
        parameters: {
            query?: {
                /** @description Filter only for the specified nodes, if not specified, no filtering. */
                nodes?: components["parameters"]["Nodes"];
                /** @description Filter only for the specified storage pools, if not specified no filtering. */
                storage_pools?: string[];
                /** @description filter by given properties, full property path */
                props?: components["parameters"]["Props"];
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
                /** @description query data from cache if available */
                cached?: components["parameters"]["Cached"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description storage pool list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoragePool"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    viewSnapshots: {
        parameters: {
            query?: {
                /** @description Filter only for the specified nodes, if not specified, no filtering. */
                nodes?: components["parameters"]["Nodes"];
                /** @description Filter only for the specified resources, if not specified, no filtering. */
                resources?: components["parameters"]["Resources"];
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description snapshot list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Snapshot"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    viewSnapshotShippings: {
        parameters: {
            query?: {
                /** @description Filter only for the specified nodes, if not specified, no filtering. */
                nodes?: components["parameters"]["Nodes"];
                /** @description Filter only for the specified resources, if not specified, no filtering. */
                resources?: components["parameters"]["Resources"];
                /** @description Filter only for the specified snapshots, if not specified, no filtering. */
                snapshots?: string[];
                /** @description Filter only for the specified status, if not specified, no filtering. */
                status?: ("running" | "complete")[];
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description physical storage list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SnapshotShippingStatus"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    resourcesStats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object stats */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceStats"];
                };
            };
            400: components["responses"]["InvalidInput"];
        };
    };
    storagePoolsStats: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Object stats */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoragePoolStats"];
                };
            };
            400: components["responses"]["InvalidInput"];
        };
    };
    viewPhysicaStorage: {
        parameters: {
            query?: {
                /** @description number of records to skip for pagination */
                offset?: components["parameters"]["Offset"];
                /** @description maximum number of records to return */
                limit?: components["parameters"]["Limit"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description physical storage list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PhysicalStorage"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    getPhysicalStorage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description physical storage list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PhysicalStorageNode"][];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    createDevicePool: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description node to use */
                node: components["parameters"]["Node"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /** @example {
                 *       "provider_kind": "LVM_THIN",
                 *       "device_path": "/dev/sde",
                 *       "pool_name": "ssd_fast",
                 *       "logcal_size_kib": 5368709120,
                 *       "vdo_enable": false
                 *     } */
                "application/json": components["schemas"]["PhysicalStorageCreate"];
            };
        };
        responses: {
            /** @description device pool created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    createSOSReport: {
        parameters: {
            query?: {
                /** @description nodes to use */
                nodes?: string[];
                /** @description use nodes where any given rsc is deployed */
                rscs?: string[];
                /** @description do not use the given nodes */
                exclude?: string[];
                /** @description include logs from ctrl */
                "include-ctrl"?: boolean;
                /** @description Unix epoch milliseconds */
                since?: components["parameters"]["Since"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description SOS report created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    downloadSOSReport: {
        parameters: {
            query?: {
                /** @description nodes to use */
                nodes?: string[];
                /** @description use nodes where any given rsc is deployed */
                rscs?: string[];
                /** @description do not use the given nodes */
                exclude?: string[];
                /** @description include logs from ctrl */
                "include-ctrl"?: boolean;
                /** @description Unix epoch milliseconds */
                since?: components["parameters"]["Since"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description SOS report ready to download as binary octet stream .tar.gz */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
    exosModifyDefault: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ExosDefaultsModify"];
            };
        };
        responses: {
            /** @description default configuration modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    exosCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ExosEnclosure"];
            };
        };
        responses: {
            /** @description Enclosure successfully created */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    exosModify: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the enclosure */
                enclosure: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ExosEnclosure"];
            };
        };
        responses: {
            /** @description Enclosure successfully modified */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    exosDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the enclosure */
                enclosure: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Enclosure successfully deleted */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiCallRcList"];
                };
            };
        };
    };
    exosDescribe: {
        parameters: {
            query?: {
                /** @description Number of events to fetch */
                count?: number;
            };
            header?: never;
            path: {
                /** @description Name of the enclosure */
                enclosure: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of EXOS events */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExosEnclosureEvent"][];
                };
            };
        };
    };
    exosMap: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of EXOS events */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExosConnectionMap"][];
                };
            };
        };
    };
    QryAllSizeInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["QueryAllSizeInfoRequest"];
            };
        };
        responses: {
            /** @description map of QSI result */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryAllSizeInfoResponse"];
                };
            };
            500: components["responses"]["OperationFailed"];
        };
    };
}
